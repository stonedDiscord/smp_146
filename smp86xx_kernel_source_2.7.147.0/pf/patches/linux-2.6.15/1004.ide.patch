diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/configs/tango2_defconfig linux-2.6.15/arch/mips/configs/tango2_defconfig
--- linux-2.6.15.ref/arch/mips/configs/tango2_defconfig	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/arch/mips/configs/tango2_defconfig	2006-10-23 14:23:03.000000000 -0700
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.15
-# Fri Aug 11 09:54:22 2006
+# Mon Oct 23 14:22:52 2006
 #
 CONFIG_MIPS=y
 
@@ -78,6 +78,7 @@
 #
 # 
 #
+CONFIG_TANGOX_HZ_VALUE=1000
 CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
 # CONFIG_TANGOX_IGNORE_CMDLINE is not set
 # CONFIG_TANGOX_PROM_CONSOLE is not set
@@ -395,9 +396,17 @@
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
 # CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/arch/mips/configs/tango3_defconfig linux-2.6.15/arch/mips/configs/tango3_defconfig
--- linux-2.6.15.ref/arch/mips/configs/tango3_defconfig	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/arch/mips/configs/tango3_defconfig	2006-10-23 14:23:21.000000000 -0700
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.15
-# Wed Aug 16 15:00:18 2006
+# Mon Oct 23 14:23:16 2006
 #
 CONFIG_MIPS=y
 
@@ -72,6 +72,7 @@
 # 
 #
 # CONFIG_TANGO3_DISABLE_HWFPU is not set
+CONFIG_TANGOX_HZ_VALUE=1000
 CONFIG_TANGOX_SYSTEMRAM_ACTUALSIZE=64
 # CONFIG_TANGOX_IGNORE_CMDLINE is not set
 # CONFIG_TANGOX_PROM_CONSOLE is not set
@@ -389,9 +390,17 @@
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_BMIDE_TANGOX=y
+CONFIG_BLK_DEV_BMIDE_TANGOX_DMA=y
+CONFIG_BLK_DEV_PBIDE_TANGOX=y
+CONFIG_BLK_DEV_PBIDE_TANGOX_DMA=y
+CONFIG_SD_CDROM_WAIT=y
+CONFIG_SD_CDROM_WAIT_TIME=5
+CONFIG_SD_CDROM_KEEP_DMA=y
+CONFIG_SD_CDROM_DMAPACKET=y
 # CONFIG_IDE_ARM is not set
-# CONFIG_BLK_DEV_IDEDMA is not set
-# CONFIG_IDEDMA_AUTO is not set
+CONFIG_BLK_DEV_IDEDMA=y
+CONFIG_IDEDMA_AUTO=y
 # CONFIG_BLK_DEV_HD is not set
 
 #
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide.c linux-2.6.15/drivers/ide/ide.c
--- linux-2.6.15.ref/drivers/ide/ide.c	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/ide.c	2006-10-23 14:22:13.000000000 -0700
@@ -805,6 +805,10 @@
 	hwif->chipset = hw->chipset;
 	hwif->gendev.parent = hw->dev;
 
+#if defined(CONFIG_BLK_DEV_BMIDE_TANGOX_MODULE) || defined(CONFIG_BLK_DEV_PBIDE_TANGOX_MODULE)
+        initializing = 1;
+#endif
+
 	if (!initializing) {
 		probe_hwif_init_with_fixup(hwif, fixup);
 		create_proc_ide_interfaces();
@@ -1854,6 +1858,18 @@
 #ifdef CONFIG_H8300
 	h8300_ide_init();
 #endif
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX
+	{
+		extern int __init tangox_bmide_init(void);
+		tangox_bmide_init();
+	}
+#endif
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX
+	{
+		extern int __init tangox_pbide_init(void);
+		tangox_pbide_init();
+	}
+#endif
 }
 
 void ide_register_subdriver(ide_drive_t *drive, ide_driver_t *driver)
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-cd.c linux-2.6.15/drivers/ide/ide-cd.c
--- linux-2.6.15.ref/drivers/ide/ide-cd.c	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/ide-cd.c	2006-10-23 14:22:13.000000000 -0700
@@ -324,6 +324,11 @@
 
 #include "ide-cd.h"
 
+#ifdef CONFIG_SD_CDROM_WAIT
+#define CONFIG_SD_CDROM_WAIT_TICKS     (CONFIG_SD_CDROM_WAIT_TIME * HZ)
+static unsigned long cdrom_wait = 0;
+#endif
+
 static DECLARE_MUTEX(idecd_ref_sem);
 
 #define to_ide_cd(obj) container_of(obj, struct cdrom_info, kref) 
@@ -487,21 +492,15 @@
 
 		if (failed_command != NULL) {
 
-			int lo=0, mid, hi= ARY_LEN (packet_command_texts);
+			int lo=0, hi= ARY_LEN (packet_command_texts);
 			s = NULL;
 
-			while (hi > lo) {
-				mid = (lo + hi) / 2;
-				if (packet_command_texts[mid].packet_command ==
+			for (lo = 0; lo < hi; lo++) {
+				if (packet_command_texts[lo].packet_command ==
 				    failed_command->cmd[0]) {
-					s = packet_command_texts[mid].text;
+					s = packet_command_texts[lo].text;
 					break;
 				}
-				if (packet_command_texts[mid].packet_command >
-				    failed_command->cmd[0])
-					hi = mid;
-				else
-					lo = mid+1;
 			}
 
 			printk (KERN_ERR "  The failed \"%s\" packet command was: \n  \"", s);
@@ -630,6 +629,11 @@
 		nsectors = 1;
 
 	ide_end_request(drive, uptodate, nsectors);
+
+#ifdef CONFIG_SD_CDROM_WAIT
+        if (uptodate)
+		cdrom_wait = 0;
+#endif
 }
 
 /* Returns 0 if the request should be continued.
@@ -756,12 +760,30 @@
 			   too many times. */
 			if (++rq->errors > ERROR_MAX)
 				do_end_request = 1;
-		} else if (sense_key == ILLEGAL_REQUEST ||
-			   sense_key == DATA_PROTECT) {
+		} else if (sense_key == DATA_PROTECT) {
 			/* No point in retrying after an illegal
 			   request or data protect error.*/
 			ide_dump_status (drive, "command error", stat);
 			do_end_request = 1;
+		} else if (sense_key == ILLEGAL_REQUEST) {
+#ifdef CONFIG_SD_CDROM_WAIT
+			if (cdrom_wait == 0)
+				cdrom_wait = jiffies;
+			if (jiffies < (cdrom_wait + CONFIG_SD_CDROM_WAIT_TICKS)) {
+				printk("%s: retrying operation.\n", drive->name);
+				do_end_request = 0;
+			} else {
+				/* No point in retrying after an illegal
+				   request or data protect error.*/
+				ide_dump_status (drive, "command error", stat);
+				do_end_request = 1;
+			}
+#else
+			/* No point in retrying after an illegal
+			   request or data protect error.*/
+			ide_dump_status (drive, "command error", stat);
+			do_end_request = 1;
+#endif
 		} else if (sense_key == MEDIUM_ERROR) {
 			/* No point in re-trying a zillion times on a bad 
 			 * sector...  If we got here the error is not correctable */
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-iops.c linux-2.6.15/drivers/ide/ide-iops.c
--- linux-2.6.15.ref/drivers/ide/ide-iops.c	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/ide-iops.c	2006-10-23 14:22:13.000000000 -0700
@@ -1068,7 +1068,14 @@
 		if (drive->current_speed >= XFER_SW_DMA_0)
 			(void) HWIF(drive)->ide_dma_on(drive);
 	} else
-		(void)__ide_dma_off(drive);
+#ifdef CONFIG_SD_CDROM_KEEP_DMA
+		/* Turn off DMA only for HDD */
+		if (drive->media == ide_disk) {
+#endif
+			(void)__ide_dma_off(drive);
+#ifdef CONFIG_SD_CDROM_KEEP_DMA
+		}
+#endif
 #endif
 }
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/ide-probe.c linux-2.6.15/drivers/ide/ide-probe.c
--- linux-2.6.15.ref/drivers/ide/ide-probe.c	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/ide-probe.c	2006-10-23 14:22:13.000000000 -0700
@@ -966,7 +966,11 @@
 {
 	request_queue_t *q;
 	ide_hwif_t *hwif = HWIF(drive);
+#ifndef MAX_KMALLOC_ORDER
 	int max_sectors = 256;
+#else
+	int max_sectors = (PAGE_SIZE<<MAX_KMALLOC_ORDER)>>9;
+#endif
 	int max_sg_entries = PRD_ENTRIES;
 
 	/*
@@ -982,7 +986,15 @@
 		return 1;
 
 	q->queuedata = drive;
+
+#if defined(CONFIG_BLK_DEV_BMIDE_TANGOX) || defined(CONFIG_BLK_DEV_PBIDE_TANGOX)
+	/* we  can handle  physical address  crossing  any boundaries,
+	 * this will make linux really merge all physically contiguous
+	 * bio */
+	blk_queue_segment_boundary(q, 0xffffffff);
+#else
 	blk_queue_segment_boundary(q, 0xffff);
+#endif
 
 	if (!hwif->rqsize) {
 		if (hwif->no_lba48 || hwif->no_lba48_dma)
@@ -990,7 +1002,7 @@
 		else
 			hwif->rqsize = 65536;
 	}
-	if (hwif->rqsize < max_sectors)
+	if ((hwif->rqsize < max_sectors) && (drive->media == ide_disk))
 		max_sectors = hwif->rqsize;
 	blk_queue_max_sectors(q, max_sectors);
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/Kconfig linux-2.6.15/drivers/ide/Kconfig
--- linux-2.6.15.ref/drivers/ide/Kconfig	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/Kconfig	2006-10-23 14:22:13.000000000 -0700
@@ -812,6 +812,46 @@
        default "128"
        depends BLK_DEV_IDE_AU1XXX
 
+config BLK_DEV_BMIDE_TANGOX
+       select IDE_GENERIC
+       tristate "BMIDE for SMP863x/SMP864x"
+       depends on TANGOX
+
+config BLK_DEV_BMIDE_TANGOX_DMA
+       select SD_CDROM_DMAPACKET if BLK_DEV_IDECD
+       bool "support BMIDE DMA operations"
+       default y
+       depends on BLK_DEV_BMIDE_TANGOX
+
+config BLK_DEV_PBIDE_TANGOX
+       select IDE_GENERIC
+       tristate "PBIDE for SMP863x/SMP864x"
+       depends on TANGOX
+
+config BLK_DEV_PBIDE_TANGOX_DMA
+       select SD_CDROM_DMAPACKET if BLK_DEV_IDECD
+       bool "support PBIDE DMA operations"
+       default y
+       depends on BLK_DEV_PBIDE_TANGOX
+
+config SD_CDROM_WAIT
+       bool "enable CDROM wait for spin-up"
+       default y
+       depends on (BLK_DEV_BMIDE_TANGOX || BLK_DEV_PBIDE_TANGOX) && BLK_DEV_IDECD
+
+config SD_CDROM_WAIT_TIME
+       int "CDROM spin-up wait time (in seconds)"
+       default 5
+       depends on SD_CDROM_WAIT
+
+config SD_CDROM_KEEP_DMA
+       bool "Keep DMA mode even I/O failed on non-HDD"
+       default y
+       depends on ((BLK_DEV_BMIDE_TANGOX && BLK_DEV_BMIDE_TANGOX_DMA) || (BLK_DEV_PBIDE_TANGOX && BLK_DEV_PBIDE_TANGOX_DMA)) && BLK_DEV_IDECD 
+
+config SD_CDROM_DMAPACKET
+	bool
+
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
@@ -1047,7 +1087,7 @@
 endif
 
 config BLK_DEV_IDEDMA
-	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA
+	def_bool BLK_DEV_IDEDMA_PCI || BLK_DEV_IDEDMA_PMAC || BLK_DEV_IDEDMA_ICS || BLK_DEV_IDE_AU1XXX_MDMA2_DBDMA || BLK_DEV_BMIDE_TANGOX_DMA || BLK_DEV_PBIDE_TANGOX_DMA
 
 config IDEDMA_IVB
 	bool "IGNORE word93 Validation BITS"
@@ -1066,7 +1106,7 @@
 	  It is normally safe to answer Y; however, the default is N.
 
 config IDEDMA_AUTO
-	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO || BLK_DEV_BMIDE_TANGOX_DMA || BLK_DEV_PBIDE_TANGOX_DMA
 
 endif
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/Makefile linux-2.6.15/drivers/ide/Makefile
--- linux-2.6.15.ref/drivers/ide/Makefile	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/drivers/ide/Makefile	2006-10-23 14:22:14.000000000 -0700
@@ -48,6 +48,6 @@
 obj-$(CONFIG_BLK_DEV_IDETAPE)		+= ide-tape.o
 obj-$(CONFIG_BLK_DEV_IDEFLOPPY)		+= ide-floppy.o
 
-obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/
+obj-$(CONFIG_BLK_DEV_IDE)		+= legacy/ arm/ mips/ tangox/
 obj-$(CONFIG_BLK_DEV_HD)		+= legacy/
 obj-$(CONFIG_ETRAX_IDE)		+= cris/
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/Makefile linux-2.6.15/drivers/ide/tangox/Makefile
--- linux-2.6.15.ref/drivers/ide/tangox/Makefile	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/Makefile	2006-10-23 14:22:14.000000000 -0700
@@ -0,0 +1,4 @@
+obj-$(CONFIG_BLK_DEV_BMIDE_TANGOX)	+= tangox-bmide.o
+obj-$(CONFIG_BLK_DEV_PBIDE_TANGOX)	+= tangox-pbide.o
+
+EXTRA_CFLAGS	:= -I../
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c linux-2.6.15/drivers/ide/tangox/tangox-bmide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-bmide.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-bmide.c	2006-10-23 14:22:14.000000000 -0700
@@ -0,0 +1,695 @@
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+
+#include "tangox-ide.h"
+
+static DEFINE_SPINLOCK(bmide_tune_chipset_spin_lock);
+
+#define PFX	"tangox_bmide: "
+
+/*
+ * helper to access host interface
+ */
+#define RD_HOST_REG32(r)	\
+		gbus_readl(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG32(r, v)	\
+		gbus_writel(REG_BASE_host_interface + (r), (v))
+
+#define RD_HOST_REG8(r)	\
+		gbus_readb(REG_BASE_host_interface + (r))
+
+#define WR_HOST_REG8(r, v)	\
+		gbus_writeb(REG_BASE_host_interface + (r), (v))
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_bmide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_bmide_outbsync(ide_drive_t *drive, u8 data,
+				unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_bmide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_bmide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_bmide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_bmide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+/*
+ * returns closest pio mode timings from given dma speed
+ */
+static u8 dma_2_pio(u8 xfer_rate) {
+
+	switch (xfer_rate) {
+	case XFER_UDMA_6:
+	case XFER_UDMA_5:
+	case XFER_UDMA_4:
+	case XFER_UDMA_3:
+	case XFER_UDMA_2:
+	case XFER_UDMA_1:
+	case XFER_UDMA_0:
+	case XFER_MW_DMA_2:
+	case XFER_PIO_4:
+		return 4;
+
+	case XFER_MW_DMA_1:
+	case XFER_PIO_3:
+		return 3;
+
+	case XFER_SW_DMA_2:
+	case XFER_PIO_2:
+		return 2;
+
+	case XFER_MW_DMA_0:
+	case XFER_SW_DMA_1:
+	case XFER_SW_DMA_0:
+	case XFER_PIO_1:
+	case XFER_PIO_0:
+	case XFER_PIO_SLOW:
+	default:
+		return 0;
+	}
+}
+
+/*
+ * dma related callbacks
+ */
+int tangox_bmide_dma_host_on(ide_drive_t *drive)
+{
+	if (drive->using_dma) {
+		ide_hwif_t *hwif = HWIF(drive);
+		u8 unit = (drive->select.b.unit & 0x01);
+		u8 dma_stat = hwif->INB(hwif->dma_status);
+
+		hwif->OUTB((dma_stat | (1 << (5 + unit))), hwif->dma_status);
+		return 0;
+	}
+	return 1;
+}
+
+int tangox_bmide_dma_host_off(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 unit = (drive->select.b.unit & 0x01);
+	u8 dma_stat = hwif->INB(hwif->dma_status);
+
+	hwif->OUTB((dma_stat & ~(1 << (5 + unit))), hwif->dma_status);
+
+	return 0;
+}
+
+int tangox_bmide_dma_check(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct hd_driveid *id = drive->id;
+	u8 pio, speed;
+
+	drive->init_speed = 0;
+
+	/* check if the drive claim to dma-able */
+	if ((id->capability & 1) && drive->autodma && ide_use_dma(drive)) {
+		u8 mode;
+
+		/* We can do all udma mode, but only with 80 conductor
+		 * cable */
+		mode = 4;
+		if ((gbus_readl(REG_BASE_host_interface +
+				IDECTRL_idestatus) & 0x02) == 0x02) {
+			printk("%s: no 80 conductors cable, falling back to "
+			       "lower udma mode\n", drive->name);
+			mode = 1;
+		}
+
+		/* find a speed supported by the drive */
+		speed = ide_dma_speed(drive, mode);
+
+		if (speed >= XFER_MW_DMA_0) {
+			/* ok, we  have one, configure  chipset for it
+			 * and apply speed to the drive */
+			hwif->speedproc(drive, speed);
+			return hwif->ide_dma_on(drive);
+		}
+	}
+
+	/* fallback to pio mode */
+	pio = ide_get_best_pio_mode(drive, 255, 5, NULL);
+	speed = dma_2_pio(XFER_PIO_0 + pio) + XFER_PIO_0;
+	hwif->speedproc(drive, speed);
+	return hwif->ide_dma_off_quietly(drive);
+}
+
+int tangox_bmide_dma_on(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (hwif->ide_dma_host_on)
+		hwif->ide_dma_host_on(drive);
+
+	if (drive->using_dma)
+		return 0;
+
+	printk("%s: DMA enabled for %s%s\n", hwif->name,
+	       drive->media == ide_disk ? "ATA DISK " :
+	       (drive->media == ide_cdrom ? "ATAPI CDROM " : ""),
+	       drive->name);
+	drive->using_dma = 1;
+
+	return 0;
+}
+
+int tangox_bmide_dma_off_quietly(ide_drive_t *drive)
+{
+	drive->using_dma = 0;
+	return 0;
+}
+
+/*
+ * dma operations
+ */
+static unsigned long g_last_dma_size = 0;
+
+static unsigned long g_mbus_reg = 0;
+static unsigned int g_next_sg = 0;
+
+static ide_startstop_t tangox_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat, stat;
+	struct request *rq;
+
+        dma_stat = hwif->ide_dma_end(drive);
+	stat = HWIF(drive)->INB(IDE_STATUS_REG);
+
+	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat | DRQ_STAT)) {
+		if (!(dma_stat & 1)) {
+			rq = HWGROUP(drive)->rq;
+			ide_end_request(drive, 1, rq->nr_sectors);
+			return ide_stopped;
+		}
+		printk(KERN_ERR PFX "%s: bad DMA status (dma_stat=%x)\n",
+		       drive->name, dma_stat);
+	}
+
+	return ide_error(drive, "dma_intr", 0);
+}
+
+static void tangox_mbus_intr(int irq, void *arg)
+{
+	ide_drive_t *drive = (ide_drive_t *)arg;
+	ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg;
+
+	if (drive->using_dma == 0) {
+		printk(KERN_ERR PFX "bug: tangox_mbus_intr called while "
+		       "using_dma == 0\n");
+		return;
+	}
+
+	em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/*
+	 * setup a new mbus transfer
+	 */
+	sg = &hwif->sg_table[g_next_sg];
+	g_next_sg++;
+
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg),
+				  sg_dma_len(sg),
+				  (g_next_sg == hwif->sg_nents) ? NULL :
+				  tangox_mbus_intr, drive)) {
+		printk(KERN_ERR PFX "fail to resetup dma, wait "
+		       "for timeout...\n");
+	}
+}
+
+static void tangox_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* issue  cmd to  drive,  and register  interrupt handler  for
+	 * command completion */
+	ide_execute_command(drive, command, &tangox_dma_intr, (2 * WAIT_CMD),
+			    NULL);
+}
+
+static void tangox_dma_start(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	unsigned long val;
+
+        rq = HWGROUP(drive)->rq;
+
+	/* setup IDE DMA transfer len */
+	gbus_writel(REG_BASE_host_interface + IDECTRL_ide_dmalen,
+		    rq->nr_sectors * 512);
+	g_last_dma_size = rq->nr_sectors * 512;
+
+	/* enable bus mastering */
+	val = 0x05;
+	if (hwif->sg_dma_direction == DMA_FROM_DEVICE)
+		val |= 0x8;
+
+	gbus_writel(REG_BASE_host_interface + IDECTRL_bmic, val);
+}
+
+static int tangox_dma_setup(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq;
+	int iswrite;
+        struct scatterlist *sg = hwif->sg_table;
+
+        rq = HWGROUP(drive)->rq;
+
+	iswrite = (rq_data_dir(rq) == WRITE);
+	hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+
+	/*
+	 * ide_map_sg will merge contiguous memory zone for us
+	 */
+        ide_map_sg(drive, rq);
+
+	/* try to setup dma channel */
+	if (em86xx_mbus_alloc_dma(SBOX_IDEDVD, iswrite ? 0 : 1, &g_mbus_reg,
+				  NULL)) {
+		printk(KERN_ERR PFX "fail to alloc dma, fallback to pio\n");
+		goto fallback_pio;
+	}
+
+	/*
+	 * map and transfer first segment
+	 */
+	dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	g_next_sg = 1;
+
+	/*
+	 * setup mbus dma for this address.  we want an mbus interrupt
+	 * only if this  is not the last sg element,  so we can refeed
+	 * mbus.
+	 */
+	if (em86xx_mbus_setup_dma(g_mbus_reg, sg_dma_address(sg),
+				  sg_dma_len(sg),
+				  (hwif->sg_nents == 1) ? NULL :
+				  tangox_mbus_intr, drive)) {
+		printk(KERN_ERR PFX "fail to setup dma, fallback to pio\n");
+		dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+			     hwif->sg_dma_direction);
+		em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+		goto fallback_pio;
+	}
+
+	drive->waiting_for_dma = 1;
+	return 0;
+
+fallback_pio:
+	ide_map_sg(drive, rq);
+	return 1;
+}
+
+static int tangox_bmide_dma_end(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+	int mbus_stat;
+        struct scatterlist *sg = hwif->sg_table;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+
+	/*
+	 * make sure DMA is not in progress
+	 */
+	if ((dma_stat & 0x7) == 1) {
+		printk(KERN_ERR PFX "huh ? dma_end called while dma still "
+		       "in progress...\n");
+	}
+
+	/* clear the INTR & ERROR bits */
+	hwif->OUTB(dma_stat | 6, hwif->dma_status);
+
+	/*
+	 * confirm  whether MBUS transfer  is done  due to  the memory
+	 * arbitration, IDE  device thinks  the DMA transfer  is done,
+	 * but the data might be held in MBUS FIFO
+	 */
+	mbus_stat = em86xx_mbus_wait(g_mbus_reg, SBOX_IDEDVD);
+
+	/* release mbus */
+	em86xx_mbus_free_dma(g_mbus_reg, SBOX_IDEDVD);
+
+	/* stop bus mastering */
+	hwif->OUTB(0x4, hwif->dma_command);
+
+	dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents,
+		     hwif->sg_dma_direction);
+	drive->waiting_for_dma = 0;
+
+	/* fake  dma  error  in  case  of mbus  timeout,  else  return
+	 * dma_status error bit */
+	return (mbus_stat == 0) ? (dma_stat & 1) : 0x1;
+}
+
+static int tangox_bmide_dma_test_irq(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	u8 dma_stat;
+
+	dma_stat = hwif->INB(hwif->dma_status);
+	if ((dma_stat & 0x4))
+		return 1;
+	return 0;
+}
+
+static int tangox_bmide_dma_lostirq(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_bmide_dma_timeout(ide_drive_t *drive)
+{
+	return 0;
+}
+#endif
+
+/*
+ * timing values for each ide mode
+ */
+static const unsigned int s_pio_tim[] = {
+	0xff230ee6, 0xd41b0fa4, 0xb4150f63, 0xa7110f62, 0x9a0f0552
+};
+
+static const unsigned int s_dma_tim[] = {
+	0xe92f2fa4, 0xa0110a63, 0x9a0f0552
+};
+static const unsigned int s_udma_tim1[] = {
+	0x35440b08, 0x35440a06, 0x35440804
+};
+static const unsigned int s_udma_tim2[] = {
+	0x00000208, 0x00000206, 0x00000204}
+;
+
+static const unsigned int s_udma_tim1_alt[] = {
+	0x44442418, 0x44441c10, 0x4444160b, 0x44441608,
+	0x44441605, 0x44441303, 0x44441302, 0x44441302
+};
+static const unsigned int s_udma_tim2_alt[] = {
+	0x0000010f, 0x0000010a, 0x00000106, 0x00000104,
+	0x00000101, 0x00000202, 0x00000202, 0x00000202
+};
+
+
+/*
+ * tangox_bmide_tune_drive
+ */
+static void tangox_bmide_tune_drive(ide_drive_t *drive, u8 pio)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+
+	if (pio == 255)
+		pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+	hwif->speedproc(drive, pio + XFER_PIO_0);
+}
+
+/*
+ * tangox_bmide_tune_chipset
+ */
+static int tangox_bmide_tune_chipset(ide_drive_t *drive, u8 xferspeed)
+{
+	int didx;
+	unsigned int ctrlreg, newflag;
+        unsigned long flags;
+	u8 mode, pio;
+
+	didx = drive->select.b.unit;
+	newflag = 0;
+
+        spin_lock_irqsave(&bmide_tune_chipset_spin_lock, flags);
+
+	if (xferspeed >= XFER_PIO_0 && xferspeed <= XFER_PIO_4) {
+		/*
+		 * setup timing for PIO mode
+		 */
+		mode = xferspeed - XFER_PIO_0;
+		printk("%s: set to PIO mode %d\n", drive->name, mode);
+
+		/* fast timing for PIO */
+		newflag = 0x01;
+
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim :
+			     IDECTRL_pri_drv1tim), s_pio_tim[mode]);
+
+	}
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	else if (xferspeed >= XFER_MW_DMA_0 && xferspeed <= XFER_MW_DMA_2) {
+		/*
+		 * setup timing for Multi-word DMA
+		 */
+		mode = xferspeed - XFER_MW_DMA_0;
+		printk("%s: set to Multi-word DMA mode %d\n", drive->name,
+		       mode);
+
+		/* fast timing for PIO, prefetch enable */
+		newflag = 0x05;
+
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0tim :
+			     IDECTRL_pri_drv1tim), s_dma_tim[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 :
+			     IDECTRL_pri_drv1udmatim1), s_udma_tim1[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 :
+			     IDECTRL_pri_drv1udmatim2), s_udma_tim2[mode]);
+
+	} else if (xferspeed >= XFER_UDMA_0 && xferspeed <= XFER_UDMA_7) {
+		unsigned int val;
+
+		/*
+		 * setup timing for Ultra DMA
+		 */
+		mode = xferspeed - XFER_UDMA_0;
+		printk("%s: set to Ultra DMA mode %d\n", drive->name, mode);
+
+		newflag = 0x00;
+
+		/* enable Ultra DMA */
+		val = gbus_readl(REG_BASE_host_interface + IDECTRL_udmactl);
+		val |= (didx == 0) ? 0x01 : 0x02;
+		gbus_writel(REG_BASE_host_interface + IDECTRL_udmactl, val);
+
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim1 :
+			     IDECTRL_pri_drv1udmatim1), s_udma_tim1_alt[mode]);
+		gbus_writel(REG_BASE_host_interface +
+			    ((didx == 0) ? IDECTRL_pri_drv0udmatim2 :
+			     IDECTRL_pri_drv1udmatim2), s_udma_tim2_alt[mode]);
+ 	}
+#endif
+
+	ctrlreg = gbus_readl(REG_BASE_host_interface + IDECTRL_pri_idectl);
+	ctrlreg &= ~(didx == 0 ? 0xf : 0xf0);
+	ctrlreg |= newflag << (didx * 4);
+	gbus_writel(REG_BASE_host_interface + IDECTRL_pri_idectl, ctrlreg);
+
+	spin_unlock_irqrestore(&bmide_tune_chipset_spin_lock, flags);
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	if (xferspeed >= XFER_SW_DMA_0)
+		pio = dma_2_pio(xferspeed);
+	else
+#endif
+		pio = xferspeed - XFER_PIO_0;
+
+	return ide_config_drive_speed(drive, xferspeed);
+}
+
+static void tangox_hw_setup(hw_regs_t *hw, unsigned long data_port,
+		     unsigned long ctrl_port)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof (*hw));
+
+	/* setup io_ports */
+	reg = data_port;
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+}
+
+
+/*
+ * init function, ide controller is registred here
+ */
+extern int tangox_bmide_enabled(void);
+
+int __init tangox_bmide_init(void)
+{
+        ide_hwif_t *hwif;
+	hw_regs_t hw;
+	int index;
+	if (!tangox_bmide_enabled()) {
+		printk(KERN_NOTICE PFX "bmide support is disabled\n");
+		return -1;
+	}
+
+	/* Enable bus master IDE interface */
+	WR_HOST_REG32(IDECTRL_pri_idectl, 0x8400);
+
+	/* no skew : normal IORDY, normal data */
+	WR_HOST_REG32(IDECTRL_idesrc, 0);
+
+	/* Enable non-PRD mode */
+	WR_HOST_REG32(IDECTRL_bmic, 0x4);
+
+	/*
+	 * set register offset for our controller
+	 */
+	tangox_hw_setup(&hw, REG_BASE_host_interface_BMIDE,
+			REG_BASE_host_interface + IDECTRL_pri_ctrlblock);
+	hw.dma = NO_DMA;
+	/*
+	 * Tango   has   two   interrupts   for   IDE   controller   :
+	 * IRQ_IDECTRL_IDE,  IRQ_IDECTRL_IDEDMA
+	 *
+	 * IRQ_IDECTRL_IDEDMA is to be used for DMA transfer but it is
+	 * almost same with IRQ_IDECTRL_IDE interrupt.  Tango triggers
+	 * IDEDMA interrupt  after DMA FIFO  is flushed, and  it stays
+	 * high   until  BMIS   register  bit   2  is   cleared.   Use
+	 * IRQ_IDECTRL_IDE interrupt for both of PIO and DMA.
+	 */
+	hw.irq = IRQ_IDECTRL_IDE;
+
+	/*
+	 * register our controller
+	 */
+	if ((index = ide_register_hw(&hw, &hwif)) < 0) {
+		printk("failed to register SMP863x/SMP864x BM IDE controller\n");
+		return -1;
+	}
+
+	printk("%s: SMP863x/SMP864x Bus Mastering IDE controller\n", hwif->name);
+
+	/*
+	 * fill controller callbacks
+	 */
+
+        /* set up local I/O function entry points */
+        hwif->INB = tangox_bmide_inb;
+        hwif->INW = tangox_bmide_inw;
+        hwif->INSW = tangox_bmide_insw;
+        hwif->OUTB = tangox_bmide_outb;
+        hwif->OUTW = tangox_bmide_outw;
+        hwif->OUTBSYNC = tangox_bmide_outbsync;
+        hwif->OUTSW = tangox_bmide_outsw;
+
+	hwif->tuneproc = &tangox_bmide_tune_drive;
+        hwif->speedproc = &tangox_bmide_tune_chipset;
+
+	hwif->drives[0].autotune = 1;
+	hwif->drives[1].autotune = 1;
+
+#ifdef CONFIG_BLK_DEV_BMIDE_TANGOX_DMA
+	/* enable dma of both ide drives */
+	hwif->drives[0].autodma = noautodma ? 0 : 1;
+	hwif->drives[1].autodma = noautodma ? 0 : 1;
+	hwif->rqsize = 256;
+
+	/* we will do autotune at dmacheck time */
+	if (noautodma == 0) {
+		hwif->drives[0].autotune = 0;
+		hwif->drives[1].autotune = 0;
+	}
+
+	/* enable  all  ultra dma  and  multiword  dma operation,  but
+	 * disable single */
+	hwif->ultra_mask = 0x7f;
+	hwif->udma_four = 1;
+	hwif->mwdma_mask = 0x07;
+	hwif->swdma_mask = 0x0;
+
+ 	hwif->autodma = 1;
+ 	hwif->atapi_dma = 1;
+
+	/* dma callbacks */
+	hwif->ide_dma_on = tangox_bmide_dma_on;
+	hwif->ide_dma_check = tangox_bmide_dma_check;
+	hwif->ide_dma_off_quietly = tangox_bmide_dma_off_quietly;
+	hwif->ide_dma_host_on = tangox_bmide_dma_host_on;
+	hwif->ide_dma_host_off = tangox_bmide_dma_host_off;
+
+	hwif->ide_dma_test_irq = tangox_bmide_dma_test_irq;
+	hwif->ide_dma_lostirq = tangox_bmide_dma_lostirq;
+	hwif->ide_dma_timeout = tangox_bmide_dma_timeout;
+
+	hwif->dma_setup = tangox_dma_setup;
+	hwif->dma_exec_cmd = tangox_dma_exec_cmd;
+	hwif->dma_start = tangox_dma_start;
+	hwif->ide_dma_end = tangox_bmide_dma_end;
+
+	hwif->dma_command = REG_BASE_host_interface + IDECTRL_bmic;
+	hwif->dma_status = REG_BASE_host_interface + IDECTRL_bmis;
+
+	em86xx_mbus_init();
+#endif
+	return 0;
+}
+
+static void __exit tangox_bmide_exit(void)
+{
+        return;
+}
+
+
+#ifdef MODULE
+module_init(tangox_bmide_init);
+module_exit(tangox_bmide_exit);
+#endif
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SMP86xx BM IDE driver");
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-ide.h linux-2.6.15/drivers/ide/tangox/tangox-ide.h
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-ide.h	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-ide.h	2006-10-23 14:22:14.000000000 -0700
@@ -0,0 +1,16 @@
+
+#ifndef __TANGOX_IDE_H
+#define __TANGOX_IDE_H
+
+#ifdef CONFIG_TANGO2
+#include <asm/tango2/hardware.h>
+#include <asm/tango2/tango2_gbus.h>
+#include <asm/tango2/tango2api.h>
+#elif defined(CONFIG_TANGO3)
+#include <asm/tango3/hardware.h>
+#include <asm/tango3/tango3_gbus.h>
+#include <asm/tango3/tango3api.h>
+#endif
+
+#endif /* __TANGOX_IDE_H */
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c linux-2.6.15/drivers/ide/tangox/tangox-pbide.c
--- linux-2.6.15.ref/drivers/ide/tangox/tangox-pbide.c	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/drivers/ide/tangox/tangox-pbide.c	2006-10-23 14:22:14.000000000 -0700
@@ -0,0 +1,533 @@
+/*
+ * driver/ide/tangox/tangox_pbide.c
+ * TANGOX PB IDE driver
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ide.h>
+#include "tangox-ide.h"
+
+extern int tangox_isaide_irq_map(void);
+extern int tangox_isaide_enabled(void);
+extern int tangox_isaide_cs_select(void);
+extern int tangox_isaide_timing_slot(void);
+
+static unsigned long g_regbase_read, g_regbase_write;
+
+/*
+ * io helpers for PIO access
+ */
+static void tangox_pbide_outb(u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outw(u16 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static void tangox_pbide_outbsync(ide_drive_t *drive, u8 data, unsigned long port)
+{
+	gbus_writew(port, data);
+}
+
+static u8 tangox_pbide_inb(unsigned long port)
+{
+	u8 val;
+
+	val = ((u8)(gbus_readw(port) & 0xff));
+	return val;
+}
+
+static u16 tangox_pbide_inw(unsigned long port)
+{
+	u16 val;
+
+	val = ((u16)(gbus_readw(port) & 0xffff));
+	return val;
+}
+
+static void tangox_pbide_insw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		*(u16 *)addr = (u16)(gbus_readw(port) & 0xffff);
+		addr += 2;
+	}
+}
+
+static void tangox_pbide_outsw(unsigned long port, void *addr, u32 count)
+{
+	while (count--) {
+		gbus_writew(port, *(u16 *)addr);
+		addr += 2;
+	}
+}
+
+//
+// data structure initialization
+//
+static void tangox_pbide_init_hwif_ports(hw_regs_t *hw, unsigned long data_port, 
+					unsigned long ctrl_port, int *irq)
+{
+	int i;
+	unsigned long reg;
+
+	memset(hw, 0, sizeof(*hw));
+
+	// setup io_ports
+	for (i = IDE_DATA_OFFSET, reg = data_port; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += 4;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = ctrl_port;
+	hw->dma = NO_DMA;
+
+	if (irq) 
+		*irq = tangox_isaide_irq_map();
+}
+
+/*
+ * tangox_pbide_tune_drive
+ */
+static void tangox_pbide_tune_drive(ide_drive_t *drive, u8 pio)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (pio == 255)
+                pio = ide_get_best_pio_mode(drive, pio, 4, NULL);
+        hwif->speedproc(drive, pio + XFER_PIO_0);
+}
+
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA
+static int tangox_pbide_dma_off_quietly(ide_drive_t *drive)
+{
+        drive->using_dma = 0;
+        return 0;
+}
+
+static int tangox_pbide_dma_test_irq(ide_drive_t *drive)
+{
+        return 1;
+}
+
+static void tangox_pbide_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+        /* issue  cmd to  drive,  and register  interrupt handler  for
+         * command completion */
+        //ide_execute_command(drive, command, &ide_dma_intr, (2 * WAIT_CMD), NULL);
+}
+
+static void tangox_pbide_dma_start(ide_drive_t *drive)
+{
+	return;
+}
+
+static int tangox_pbide_dma_lostirq(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_timeout(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_on(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_host_off(ide_drive_t *drive)
+{
+	return 0;
+}
+
+static int tangox_pbide_dma_on(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+
+        if (hwif->ide_dma_host_on)
+                hwif->ide_dma_host_on(drive);
+
+        printk("IDE: DMA enabled for %s%s\n",
+                drive->media == ide_disk ? "ATA DISK " :
+                (drive->media == ide_cdrom ? "ATAPI CDROM " : ""),
+                drive->name);
+        drive->using_dma = 1;
+        return 0;
+}
+
+/*
+ * Calculate the peripheral bus timing needed for the register used by IDE
+ * devices.
+ */
+
+/* 
+ * The tables bellows use indices as Multi-word DMA 2, Multi-word DMA 1,
+ * Multi-word DMA 0, PIO 4, PIO 3, PIO 2, PIO 1, and PIO 0 (From 0 to 7, 
+ * respectively).
+ */
+
+/* For storing value pair */
+typedef struct {
+	unsigned char x;
+	unsigned char y;
+} value_pair;
+
+/* Table used for calculate Ta and Tb */
+static const value_pair tab_values[] = {
+	{3,0}, {5,0}, {7,2}, {3,0}, {5,0}, {5,0}, {7,2}, {10,4}
+};
+
+/* Table used for calculate Tc */
+static const value_pair tc_values[] = {
+	{13,8}, {19,11}, {60,41}, {10,5}, {12,6}, {14,8}, {17,11}, {23,15}
+};
+
+/* Table used for calculate Td */
+static const value_pair td_values[] = {
+	{1,100}, {1,100}, {3,200}, {1,100}, {1,100}, {1,100}, {3,200}, {5,250}
+};
+
+/* 
+ * Calculate the required timing for setting up peripheral bus timing register.
+ *
+ * Input: sysclk = system clock rate (in MHz)
+ *        mode = IDE mode (0-2: Multiword DMA mode 2-0, 3-7: PIO mode 4-0)
+ * Return: 0 = Error
+ *         else = value for setting up the timing register
+ */
+static unsigned long get_pb_ide_timing(unsigned int sysclk, int mode)
+{
+	unsigned char ta = 0;
+	unsigned char tb = 0;
+	unsigned char tc = 0;
+	unsigned char td = 0;
+	long temp = 0;
+	const value_pair *val_ptr = (const value_pair *)0;
+
+	/* The formula is only effective between 100-240MHz */
+	if ((sysclk < 100) && (sysclk > 240))
+		return(0);
+	else if ((mode < 0) && (mode > 7)) /* Mode index is 0-7 only */
+		return(0);
+
+	/* (x, y) = tab_values[mode] */
+	/* (Ta + Tb) = Temp = (ceiling((sysclk - 100) * x / 140) + y) */
+	/* Ta = ceiling(Temp / 2) */
+	/* Tb = (Temp / 2) */
+	val_ptr = &tab_values[mode];
+	temp = ((sysclk - 100) * val_ptr->x) / 140;
+	if ((temp * 140) < ((sysclk - 100) * val_ptr->x))
+		temp++;
+	temp += val_ptr->y;
+	tb = ta = (unsigned char)((temp >> 1) & 0xff);
+	if (temp & 0x1)
+		ta++;
+
+	/* (x, y) = tc_values[mode] */
+	/* Tc = (ceiling((sysclk - 100) * x / 140) + y) */
+	val_ptr = &tc_values[mode];
+	tc = (unsigned char)(((sysclk - 100) * val_ptr->x) / 140) & 0xff;
+	if ((tc * 140) < ((sysclk - 100) * val_ptr->x))
+		tc++;
+	tc += val_ptr->y;
+
+	/* (x, y) = td_values[mode] */
+	/* Td = ceiling(sysclk + y - 400) * x / y) */
+	val_ptr = &td_values[mode];
+	if ((temp = (sysclk + val_ptr->y) - 400) < 0)
+		td = 0; /* It's possible that Td < 0, so we set it to 0 */
+	else {
+		td = (unsigned char)(((temp * val_ptr->x) / val_ptr->y) & 0xff);
+		if ((td * val_ptr->y) < (temp * val_ptr->x))
+			td++;
+	}
+	return((td << 24) | (tc << 16) | (tb << 8) | ta);
+}
+
+ide_startstop_t tangox_pbide_dma_intr(ide_drive_t *drive)
+{
+	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = HWGROUP(drive)->rq;
+
+	hwif->ide_dma_end(drive);
+
+	ide_end_request(drive, 1,rq->nr_sectors);
+
+	return ide_stopped;
+}
+
+static int tangox_pbide_rwdma(ide_drive_t *drive, int read, struct request *rq)
+{
+	unsigned long size = 0;
+	unsigned long addr = 0;
+
+        ide_hwif_t *hwif = HWIF(drive);
+        struct scatterlist *sg = hwif->sg_table;
+
+        dma_map_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+
+	if (hwif->sg_nents > 2) { /* this shouldn't happen since we limited rqsize=16 for now*/
+      		printk("cannot handle multiple transfer yet. sg_nents=0x%x\n", hwif->sg_nents);
+                dma_unmap_sg(&hwif->gendev, sg, hwif->sg_nents, hwif->sg_dma_direction);
+	        return 1;
+	}
+
+	// setup switchbox and wait for its readiness
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  1, &g_regbase_read, NULL)) {
+                printk("fail to alloc read dma, fallback to pio.\n");
+		return 1;
+        }
+
+        /* try to setup dma write channel */
+        if (em86xx_mbus_alloc_dma(SBOX_IDEFLASH,  0, &g_regbase_write, NULL)) {
+                printk("fail to alloc write dma, fallback to pio.\n");
+		em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+		return 1;
+        }
+
+	// setup handler
+	if (drive->media == ide_disk)
+		ide_set_handler(drive, &tangox_pbide_dma_intr, 2 * WAIT_CMD, NULL);
+
+        addr = sg_dma_address(sg);
+       	size = sg_dma_len(sg);
+
+	if (hwif->sg_nents == 1) {
+
+		/* perform a single (linear/rectangle) transfer */
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | (size >> 1));
+
+	        if (read)
+        	        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+	        else
+	                dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+
+        	em86xx_mbus_setup_dma(read ? g_regbase_read : g_regbase_write,
+                		addr, size, NULL, NULL);
+	}
+	else { 
+		/* perform a double transfer */
+		unsigned int addr1 = 0;
+		unsigned int size1 = 0;
+
+		sg = &hwif->sg_table[1];
+
+	        addr1 = sg_dma_address(sg);
+	       	size1 = sg_dma_len(sg);
+
+	        // setup PB automode registers
+	        gbus_writel(REG_BASE_host_interface + PB_automode_start_address, 0);
+	        gbus_writel(REG_BASE_host_interface + PB_automode_control,
+				0x00140000 | ((read ? 1 : 0) << 16) | ((size+size1) >> 1));
+
+                if (read) {
+                        dma_cache_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_inv((unsigned int)phys_to_virt(addr1), size1);
+		} else {
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr), size);
+                        dma_cache_wback_inv((unsigned int)phys_to_virt(addr1), size1);
+		}
+
+                mbus_setup_dma_double(read ? g_regbase_read : g_regbase_write, 
+				addr, size, addr1, size1);
+	}
+
+	if (drive->media == ide_disk) {
+		// send IDE command
+		HWIF(drive)->OUTB(read ? (drive->addressing ? WIN_READDMA_EXT : WIN_READDMA) : 
+			(drive->addressing ? WIN_WRITEDMA_EXT : WIN_WRITEDMA), IDE_COMMAND_REG);
+	}
+
+	return 0;
+}
+
+static int tangox_pbide_dma_setup(ide_drive_t *drive)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        struct request *rq;
+        int iswrite;
+
+        drive->waiting_for_dma = 1;
+        rq = HWGROUP(drive)->rq;
+        iswrite = (rq_data_dir(rq) == WRITE);
+        hwif->sg_dma_direction = iswrite ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	
+	// this will do the merge
+	ide_map_sg(drive, rq);
+
+        return tangox_pbide_rwdma(drive, !iswrite, rq);
+}
+
+static int tangox_ide_config_drive_for_dma(ide_drive_t *drive, int mode)
+{
+        ide_hwif_t *hwif = HWIF(drive);
+        int config_allows_dma = 0;
+        struct hd_driveid *id = drive->id;
+        int speed;
+
+        // enable DMA for CDROM by default
+        if (drive->media == ide_disk || drive->media == ide_cdrom)
+                config_allows_dma = 1;
+
+        if (id && (id->capability & 1) && hwif->autodma && config_allows_dma) {
+                speed = ide_dma_speed(drive, mode);
+
+                /* For CDROM, we do the max. MDMA mode 2 */
+		//if ((speed > XFER_MW_DMA_2) && (drive->media == ide_cdrom))
+		//	speed = XFER_MW_DMA_2;
+
+                if (speed >= XFER_MW_DMA_0) {
+                        if (hwif->speedproc)
+                                hwif->speedproc(drive, speed);
+                        ide_config_drive_speed(drive, speed);
+                        return hwif->ide_dma_on(drive);
+                }
+        }
+
+        return hwif->ide_dma_off_quietly(drive);
+}
+
+static int tangox_pbide_dma_check(ide_drive_t *drive)
+{
+	return tangox_ide_config_drive_for_dma(drive, 0);
+}
+
+static void tangox_pbide_tune_chipset_drive(int drive, int speed, int verbose)
+{
+	extern unsigned long em8xxx_sys_frequency;
+	int mode = speed & 0x0f;
+	unsigned int timing;
+	
+	if (speed >= XFER_PIO_0 && speed <= XFER_PIO_4)
+		mode -= 8;
+	else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2)
+		mode += 5;
+	else
+		return;	
+
+	// get_pb_ide_timing() receives mode in reversed order
+	//   PIO : 7-3
+	//   Multi-word DMA : 2-0
+	mode = 7 - mode;
+	timing = get_pb_ide_timing(em8xxx_sys_frequency * 11 / (10*1000000), mode);
+	gbus_writel(REG_BASE_host_interface + PB_timing_slot(tangox_isaide_timing_slot()), timing);
+}
+
+static int tangox_pbide_tune_chipset(ide_drive_t *drive, u8 speed)
+{
+	tangox_pbide_tune_chipset_drive(drive->select.b.unit, speed, 1);
+
+	return ide_config_drive_speed(drive, speed);
+}
+
+static int tangox_pbide_dma_end_io(ide_drive_t *drive)
+{
+	struct request *rq = HWGROUP(drive)->rq;
+
+	int stat = em86xx_mbus_wait(rq->cmd == READ ? g_regbase_read : 
+					g_regbase_write, SBOX_IDEFLASH);
+
+	/* Free up MBUS channel */
+	em86xx_mbus_free_dma(g_regbase_read, SBOX_IDEFLASH);
+	em86xx_mbus_free_dma(g_regbase_write, SBOX_IDEFLASH);
+	return((stat != 0) ? 1 : 0);
+}
+
+static int tangox_pbide_dma_end(ide_drive_t *drive)
+{
+	int status;
+
+	drive->waiting_for_dma = 0;
+	status = tangox_pbide_dma_end_io(drive);
+	return(status);
+}
+#endif
+
+//
+// initialize IDE driver
+//
+int __init tangox_pbide_init(void)
+{
+	int index, i;
+	ide_hwif_t *hwif;
+	hw_regs_t hw;
+#ifdef MODULE
+        ide_drive_t *drive = NULL;
+#endif
+
+	if (tangox_isaide_enabled() == 0)
+		return 0;
+	else
+		tangox_pbide_init_hwif_ports(&hw, 
+			REG_BASE_host_interface_ISAIDE(tangox_isaide_cs_select()), 0, &hw.irq);
+
+       	index = ide_register_hw(&hw, &hwif);
+	printk("%s: SMP863x/SMP864x PB IDE controller.\n", hwif->name);
+
+	// initialize ide_hwifs data structure
+	// supports only one interface
+	for (i = index; i < index + 1; ++i) {
+		// register DMA handler
+		hwif = &ide_hwifs[i];
+
+	        /* set up local I/O function entry points */
+	        hwif->INB = tangox_pbide_inb;
+	        hwif->INW = tangox_pbide_inw;
+	        hwif->INSW = tangox_pbide_insw;
+	        hwif->OUTB = tangox_pbide_outb;
+	        hwif->OUTW = tangox_pbide_outw;
+	        hwif->OUTBSYNC = tangox_pbide_outbsync;
+	        hwif->OUTSW = tangox_pbide_outsw;
+
+		hwif->rqsize = 16; 
+
+	    if (!noautodma) {
+#ifdef CONFIG_BLK_DEV_PBIDE_TANGOX_DMA 
+		hwif->autodma = 1;
+		hwif->atapi_dma = 1;
+		hwif->ultra_mask = 0x00;	// dpbble all Ultra DMA
+		hwif->mwdma_mask = 0x07;	// enable all Multi-word DMA
+		hwif->swdma_mask = 0x80;	// dpbble all Single-word DMA
+
+	        hwif->dma_setup = tangox_pbide_dma_setup;
+	        hwif->dma_exec_cmd = tangox_pbide_dma_exec_cmd;
+	        hwif->dma_start = tangox_pbide_dma_start;
+		hwif->ide_dma_end = tangox_pbide_dma_end;
+
+		hwif->ide_dma_check = tangox_pbide_dma_check;
+		hwif->ide_dma_on = tangox_pbide_dma_on;
+		hwif->ide_dma_off_quietly = tangox_pbide_dma_off_quietly;
+		hwif->ide_dma_test_irq = tangox_pbide_dma_test_irq;
+		hwif->ide_dma_host_on = tangox_pbide_dma_host_on;
+		hwif->ide_dma_host_off = tangox_pbide_dma_host_off;
+		hwif->ide_dma_lostirq = tangox_pbide_dma_lostirq;
+		hwif->ide_dma_timeout = tangox_pbide_dma_timeout;
+	      	hwif->tuneproc = tangox_pbide_tune_drive;
+		hwif->speedproc = tangox_pbide_tune_chipset;
+#endif
+	    }
+	}
+
+	return 0;
+}
+
+void __exit tangox_pbide_exit(void)
+{
+        return;
+}
+
+#ifdef MODULE
+module_init(tangox_pbide_init);
+module_exit(tangox_pbide_exit);
+#endif
+
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/include/linux/cdrom.h linux-2.6.15/include/linux/cdrom.h
--- linux-2.6.15.ref/include/linux/cdrom.h	2006-10-23 14:20:22.000000000 -0700
+++ linux-2.6.15/include/linux/cdrom.h	2006-10-23 14:22:14.000000000 -0700
@@ -287,6 +287,10 @@
 	unsigned char		data_direction;
 	int			quiet;
 	int			timeout;
+#ifdef CONFIG_SD_CDROM_DMAPACKET
+	int                     do_dma;         /* Try to use DMA */
+	int                     dma_error;      /* A DMA_specific error occurred */
+#endif
 	void			__user *reserved[1];	/* unused, actually */
 };
 
diff -Naur --exclude=CVS --exclude='*.o' --exclude='*.a' --exclude='*.so' --exclude='*.elf' --exclude=System.map --exclude=Makefile.d --exclude='*log' --exclude='*log2' --exclude='*~' --exclude='.*~' --exclude='.#*' --exclude='*.bak' --exclude='*.orig' --exclude='*.rej' --exclude='core.[0-9]*' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=.depend --exclude='.*.o.flags' --exclude='*.gz' --exclude=vmlinux --exclude=vmlinux.bin --exclude=yamon-02.06-SIGMADESIGNS-01_el.bin linux-2.6.15.ref/README.1004.ide.patch linux-2.6.15/README.1004.ide.patch
--- linux-2.6.15.ref/README.1004.ide.patch	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.15/README.1004.ide.patch	2006-10-23 14:25:12.000000000 -0700
@@ -0,0 +1,20 @@
+Feature:
+--------
+Bus Mastering IDE and PB IDE controllers support for SMP863x/SMP864x
+
+Prerequisite patch numbers:
+---------------------------
+0000
+1000
+1003
+
+Primary author:
+---------------
+External (Craig Qu)
+
+Related to which chip version SMP86xx xx=?
+-----------------------------------------
+Tango2 ES6/RevA or above, or Tango3 ES1 or above
+
+(linux patches) which CONFIG_... are provided:
+----------------------------------------------
