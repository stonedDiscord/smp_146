diff -Naur linux.org/drivers/net/Config.in linux.patched/drivers/net/Config.in
--- linux.org/drivers/net/Config.in	2004-02-05 19:14:47.000000000 +0100
+++ linux.patched/drivers/net/Config.in	2004-02-05 19:15:17.000000000 +0100
@@ -2,6 +2,9 @@
 # Network device configuration
 #
 
+if [ "$CONFIG_ARCH_EM86XX" = "y" -o "$CONFIG_TANGO2" = "y" ]; then
+   bool 'GNET support' CONFIG_GNET
+fi
 source drivers/net/arcnet/Config.in
 
 tristate 'Dummy net driver support' CONFIG_DUMMY
diff -Naur linux.org/drivers/net/Makefile linux.patched/drivers/net/Makefile
--- linux.org/drivers/net/Makefile	2004-02-05 19:15:00.000000000 +0100
+++ linux.patched/drivers/net/Makefile	2004-02-05 19:15:27.000000000 +0100
@@ -8,7 +8,7 @@
 obj-n           :=
 obj-            :=
 
-mod-subdirs     := appletalk arcnet fc irda tokenring pcmcia wireless wan
+mod-subdirs     := appletalk arcnet fc irda tokenring pcmcia wireless wan gnet
 
 O_TARGET := net.o
 
@@ -27,6 +27,10 @@
 
 obj-$(CONFIG_OCP_NET) += ibm_emac/ocp.o
 
+ifeq ($(CONFIG_GNET),y)
+  obj-y += gnet/gnetdrv.o
+endif
+
 ifeq ($(CONFIG_E1000),y)
   obj-y += e1000/e1000.o
 endif
@@ -54,6 +58,7 @@
 subdir-$(CONFIG_E100) += e100
 subdir-$(CONFIG_E1000) += e1000
 subdir-$(CONFIG_BONDING) += bonding
+subdir-$(CONFIG_GNET) += gnet
 
 #
 # link order important here
diff -Naur linux.org/drivers/net/gnet/Makefile linux.patched/drivers/net/gnet/Makefile
--- linux.org/drivers/net/gnet/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/Makefile	2005-07-29 10:11:27.477055062 +0200
@@ -0,0 +1,18 @@
+# Makefile for linux/drivers/net/arcnet
+#
+# Note! Dependencies are done automagically by 'make dep', which also
+# removes any old dependencies. DON'T put your own dependencies here
+# unless it's something special (ie not a .c file).
+#
+
+obj-y	:=
+obj-n	:=
+obj-m	:=
+obj-	:=
+export-objs :=  
+
+obj-$(CONFIG_GNET) += probe.o net.o gnet_k.o emhwlib.o dbgimplementation.o
+
+O_TARGET := gnetdrv.o
+
+include $(TOPDIR)/Rules.make
diff -Naur linux.org/drivers/net/gnet/common.h linux.patched/drivers/net/gnet/common.h
--- linux.org/drivers/net/gnet/common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/common.h	2005-07-29 10:11:27.379068594 +0200
@@ -0,0 +1,60 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   common.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2002-11-13
+*/
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#ifndef CONFIG_GNET
+#define ALLOW_OS_CODE 1
+#include "../rmdef/rmdef.h"
+
+#include "../llad/include/llad.h"
+#include "../llad/include/gbus.h"
+
+#include "../gbuslib/include/gbus_mutex.h"
+#include "../gbuslib/include/gbus_fifo.h"
+#include "../gbuslib/include/gbus_logger.h"
+
+#include "../emhwlib_hal/include/emhwlib_registers.h"
+#include "../emhwlib/include/emhwlib_resources.h"
+#include "../emhwlib_hal/include/emhwlib_lram.h"
+#include "../emhwlib/include/emhwlib_event.h"
+
+
+struct kc_tasklet_struct;
+#if (EM86XX_MODE==EM86XX_MODEID_WITHHOST) 
+#include "../llad/mum/include/mum_kk.h"
+#elif (EM86XX_MODE==EM86XX_MODEID_STANDALONE)
+#include "../llad/direct/include/direct_kk.h"
+#endif //EM86XX_MODE
+
+#else // CONFIG_GNET
+
+#ifndef __RMEM86XXID_H__
+// mips kernels have the integral rmem86xxid.h already. arm kernels: in gnet patch only
+#include "rmem86xxid.h"
+#endif
+
+#include "emhwlib.h"
+#endif
+
+#include "macros.h"
+
+#include "minor.h"
+#include "probe.h"
+#include "gnet_k.h"
+#include "net.h"
+
+#endif // __COMMON_H__
diff -Naur linux.org/drivers/net/gnet/dbgimplementation.c linux.patched/drivers/net/gnet/dbgimplementation.c
--- linux.org/drivers/net/gnet/dbgimplementation.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/dbgimplementation.c	2005-07-29 10:11:27.436060723 +0200
@@ -0,0 +1,57 @@
+/*****************************************
+ Copyright © 2001-2003	
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+#include "kernelheaders.h"
+#include "common.h"
+
+/*
+  Avoid to allocate string buffers on stack because stack is limited.
+
+  Doing as below causes the logging function to be not reentrant, both
+  because of static str and because of logboard.
+
+  When concurrency occurs, only consequence is that logging becomes 
+  incorrect: no big deal
+ */
+
+#define RM_MAX_STRING 1000
+static char str[RM_MAX_STRING];
+int logboard=-1;
+
+#ifndef RMDBGLOG_implementation
+void RMDBGLOG_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{  
+        if (active) {
+		va_list ap;
+		
+		if (logboard==-1) 
+			snprintf(str,RM_MAX_STRING,"gnet [%s:%ld] ",(char *)filename,line);
+		else
+			snprintf(str,RM_MAX_STRING,"gnet%d [%s:%ld] ",logboard,(char *)filename,line);
+		
+                va_start(ap, text);
+                vsnprintf(str+strlen(str), RM_MAX_STRING-strlen(str), text, ap);
+		va_end(ap);
+                
+		printk(str);
+        }
+}
+#endif // RMDBGLOG_implementation
+
+#ifndef RMDBGPRINT_implementation
+void RMDBGPRINT_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...)
+{
+        if (active) {
+		va_list ap;
+		
+                va_start(ap, text);
+                vsnprintf(str,RM_MAX_STRING,text,ap);
+                va_end(ap);
+                
+               	printk(str);
+        }
+}
+#endif // RMDBGPRINT_implementation
diff -Naur linux.org/drivers/net/gnet/emhwlib.c linux.patched/drivers/net/gnet/emhwlib.c
--- linux.org/drivers/net/gnet/emhwlib.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/emhwlib.c	2005-07-29 10:11:27.450058790 +0200
@@ -0,0 +1,156 @@
+#include "kernelheaders.h"
+#include "common.h"
+
+#if (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+#include <asm/tango2/hardware.h>
+#endif
+
+struct gbus_fifo *gbus_fifo_open(struct gbus *pgbus, RMuint32 data_address, RMuint32 data_size, RMuint32 fifo_address)
+{
+	struct gbus_fifo *fifo = (struct gbus_fifo *) fifo_address;
+	
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->base), data_address);
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->size), data_size);
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->rd), 0);
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->wr), 0);
+	
+	return fifo;
+}
+
+void gbus_fifo_get_pointer(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *base, RMuint32 *size, RMuint32 *rd_ptr, RMuint32 *wr_ptr)
+{
+	*base = gbus_read_uint32(pgbus, (RMuint32) &(fifo->base));
+	*size = gbus_read_uint32(pgbus, (RMuint32) &(fifo->size));
+	*rd_ptr = gbus_read_uint32(pgbus, (RMuint32) &(fifo->rd));
+	*wr_ptr = gbus_read_uint32(pgbus, (RMuint32) &(fifo->wr));
+}
+
+RMuint32 gbus_fifo_get_readable_size(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *rd_ptr1, RMuint32 *rd_size1, RMuint32 *rd_ptr2)
+{
+	RMuint32 base, size, rd, wr;
+	
+	gbus_fifo_get_pointer(pgbus, fifo, &base, &size, &rd, &wr);
+	
+	*rd_ptr1 = base + rd;
+	
+	if (wr >= rd) {
+		*rd_size1 = wr - rd;
+		*rd_ptr2 = 0;
+		return (*rd_size1);
+	}
+	else {
+		*rd_size1 = size - rd;
+		*rd_ptr2 = base;
+		return (*rd_size1 + wr);
+	}
+}
+
+RMuint32 gbus_fifo_get_writable_size(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *wr_ptr1, RMuint32 *wr_size1, RMuint32 *wr_ptr2)
+{
+	RMuint32 base, size, rd, wr;
+	
+	gbus_fifo_get_pointer(pgbus, fifo, &base, &size, &rd, &wr);
+	
+	*wr_ptr1 = base + wr;
+	
+	if (wr >= rd) {
+		if (rd > 0) {
+			*wr_size1 = size - wr;
+			*wr_ptr2 = base;
+			return (*wr_size1 + rd - 1);
+		}
+		else {
+			*wr_size1 = size - 1 - wr;
+			*wr_ptr2 = 0;
+			return (*wr_size1);
+		}			
+	}
+	else {
+		*wr_size1 = rd - 1 - wr;
+		*wr_ptr2 = 0;
+		return (*wr_size1);
+	}
+}
+
+RMuint32 gbus_fifo_incr_write_ptr(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 incr)
+{
+	RMuint32 base, size, rd, wr;
+	
+	gbus_fifo_get_pointer(pgbus, fifo, &base, &size, &rd, &wr);
+	
+	wr += incr;
+	if (wr >= size)
+		wr -= size;
+	
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->wr), wr);
+		
+	return wr + base;
+}
+
+RMuint32 gbus_fifo_incr_read_ptr(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 incr)
+{
+	RMuint32 base, size, rd, wr;
+	
+	gbus_fifo_get_pointer(pgbus, fifo, &base, &size, &rd, &wr);
+	
+	rd += incr;
+	if (rd >= size)
+		rd -= size;
+		
+	gbus_write_uint32(pgbus, (RMuint32) &(fifo->rd), rd);
+	
+	return rd + base;
+}
+
+static unsigned long *tasklet_status = (unsigned long *) NULL;
+static struct tasklet_struct *tasklet = (struct tasklet_struct *) NULL;
+static unsigned long tasklet_mask = 0;
+
+static void tophalf(int irq, void *dev_id, struct pt_regs *regs) 
+{
+	unsigned long status;
+	unsigned long mask;
+	unsigned long flags;
+
+	status = gbus_read_uint32(pGBus, REG_BASE_cpu_block + CPU_irq_softset);
+
+	if ((status & SOFT_IRQ_ORIGIN_PT110) == 0) {
+		printk("Invalid software interrupt 0x%08lx\n", status);
+		return;
+	}
+	
+ 	gbus_mutex_lock(pGBus, SOFT_IRQ_MUTEX_IRQ);
+
+	status = gbus_read_uint32(pGBus, HOST_INTERRUPT_STATUS);
+	mask = status & (tasklet_mask);
+	status &= ~(tasklet_mask); 
+	gbus_write_uint32(pGBus, HOST_INTERRUPT_STATUS, status);
+	if (status == 0)
+		gbus_write_uint32(pGBus, REG_BASE_cpu_block + CPU_irq_softclr, SOFT_IRQ_ORIGIN_PT110);
+	
+	gbus_mutex_unlock(pGBus, SOFT_IRQ_MUTEX_IRQ);
+
+	if ((mask) && (tasklet)) {
+		*tasklet_status |= mask;
+		tasklet_schedule(tasklet);
+	}
+}
+
+void mumk_register_tasklet(struct gbus *pgbus, struct kc_tasklet_struct *kctasklet, RMuint32 *irq_status, RMuint32 mask)
+{
+	request_irq(IRQ_SOFTINT, tophalf, SA_INTERRUPT | SA_SHIRQ, "gnet0", &(Gtable[0]));
+	tasklet_status = irq_status;
+	tasklet = (struct tasklet_struct *)kctasklet;
+	tasklet_mask = mask;
+	printk("mumk_register_tasklet: done\n");
+}
+
+void mumk_unregister_tasklet(struct gbus *pgbus, struct kc_tasklet_struct *kctasklet)
+{
+	tasklet_mask = 0;
+	tasklet = (struct tasklet_struct *) NULL; 
+	tasklet_status = (unsigned long *) NULL; 
+	free_irq(IRQ_SOFTINT, &(Gtable[0]));
+	printk("mumk_unregister_tasklet: cannot unregister\n");
+}
+
diff -Naur linux.org/drivers/net/gnet/emhwlib.h linux.patched/drivers/net/gnet/emhwlib.h
--- linux.org/drivers/net/gnet/emhwlib.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/emhwlib.h	2005-07-29 10:11:27.397066108 +0200
@@ -0,0 +1,216 @@
+#ifndef __EMHWLIB_H__
+#define __EMHWLIB_H__
+
+#if (defined CONFIG_ARCH_MAMBO)
+#define EM86XX_CHIP EM86XX_CHIPID_MAMBOLIGHT
+#elif (defined CONFIG_ARCH_TANGO)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGOLIGHT
+#elif (defined CONFIG_TANGO2)
+#define EM86XX_CHIP EM86XX_CHIPID_TANGO2
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+#define RMascii char 
+#define RMbool RMuint8
+#define RMint32 long
+#define RMuint32 unsigned long
+#define RMuint8 unsigned char
+
+#define ENABLE TRUE, __FILE__, __LINE__
+#define DISABLE FALSE, __FILE__, __LINE__
+
+void RMDBGLOG_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...);
+void RMDBGPRINT_implementation(RMbool active,const RMascii *filename,RMint32 line,const RMascii *text,...);
+
+#define RMASSERT(x)
+#define RMDBGLOG(x) RMDBGLOG_implementation x
+#define RMDBGPRINT(x) RMDBGPRINT_implementation x
+#define gbus_logger(x,y,z)
+
+#define RMmin(x,y) (((x) < (y)) ? (x) : (y))
+
+#define RMmustBeEqual(x,y,seed)                 \
+typedef char XXX ## seed ## LeftIsBiggerNow[(y)-(x)];           \
+typedef char XXX ## seed ## LeftIsSmallerNow[(x)-(y)];
+#define RMleftMustBeSmaller(x,y,seed)                 \
+typedef RMascii XXX ## seed ## LeftIsBiggerNow[(y)-(x)];           
+
+#define SOFT_IRQ_ORIGIN_PT110      (1<<4)
+
+#define LOG2_LLAD_GNET0RX                       5
+#define LOG2_LLAD_GNET1RX                       6
+#define LLAD_GNET0RX                       (1 << LOG2_LLAD_GNET0RX)
+#define LLAD_GNET1RX                       (1 << LOG2_LLAD_GNET1RX)
+
+struct gbus;
+struct llad;
+
+#if (EM86XX_CHIP!=EM86XX_CHIPID_TANGO2)
+
+#include "emhwlib_dram.h"
+#include "emhwlib_resources.h"
+#include "emhwlib_registers.h"
+#define EM86XX_MODE EM86XX_MODEID_STANDALONE
+
+#define pGBus ((struct gbus *) 1)
+#define pLLAD ((struct llad *) 1)
+
+static inline struct llad *llad_open(char *dev)
+{
+	if (*dev == '0')
+		return pLLAD;
+	else
+		return (struct llad *) NULL;
+}
+
+static inline void llad_close(struct llad *pllad)
+{
+}
+
+static inline struct gbus *gbus_open(struct llad *pllad)
+{
+	return pGBus;
+}
+
+static inline void gbus_close(struct gbus *pgbus)
+{
+}
+
+static inline RMuint8  gbus_read_uint8 (struct gbus *h, RMuint32 byte_address)
+{
+	return *((volatile RMuint8 *) byte_address);
+}
+
+static inline RMuint32 gbus_read_uint32(struct gbus *h, RMuint32 byte_address)
+{
+	return *((volatile RMuint32 *) byte_address);
+}
+
+static inline void gbus_write_uint8 (struct gbus *h, RMuint32 byte_address, RMuint8  data)
+{
+	*((volatile RMuint8 *) byte_address) = data;
+}
+
+static inline void gbus_write_uint32(struct gbus *h, RMuint32 byte_address, RMuint32 data)
+{
+	*((volatile RMuint32 *) byte_address) = data;
+}
+
+#else /* tango2 */
+
+#include "asm/tango2/rmdefs.h"
+#include "asm/tango2/emhwlib_dram.h"
+#include "asm/tango2/emhwlib_lram.h"
+#include "asm/tango2/emhwlib_registers_tango2.h"
+#include "asm/tango2/emhwlib_resources_tango2.h"
+#include "asm/tango2/emhwlib_resources_shared.h"
+
+#define pLLAD ((struct llad *) 1)
+
+static inline struct llad *llad_open(char *dev)
+{
+	if (*dev == '0')
+		return pLLAD;
+	else
+		return (struct llad *) NULL;
+}
+
+static inline void llad_close(struct llad *pllad)
+{
+}
+
+static inline struct gbus *gbus_open(struct llad *pllad)
+{
+	return pGBus;
+}
+
+static inline void gbus_close(struct gbus *pgbus)
+{
+}
+
+#ifndef __KERNEL__
+static inline RMuint8  gbus_read_uint8 (struct gbus *h, RMuint32 byte_address)
+{
+	return *((volatile RMuint8 *) KSEG1ADDR(byte_address));
+}
+
+static inline void gbus_write_uint8 (struct gbus *h, RMuint32 byte_address, RMuint8  data)
+{
+	*((volatile RMuint8 *) KSEG1ADDR(byte_address)) = data;
+}
+#endif
+#endif
+
+static inline void gbus_read_data8 (struct gbus *h, RMuint32 byte_address, RMuint8  *data, RMuint32 count)
+{
+	RMuint32 i;
+
+	for (i=0 ; i<count ; i++) {
+		*(data+i) = gbus_read_uint8(h, byte_address + i);
+	}
+}
+
+static inline void gbus_write_data8 (struct gbus *h, RMuint32 byte_address, RMuint8  *data, RMuint32 count)
+{
+	RMuint32 i;
+
+	for (i=0 ; i<count ; i++) {
+		gbus_write_uint8(h, byte_address + i, *(data+i));
+	}
+}
+
+#define gbus_save_flags_clf(x)               \
+        {                               \
+                RMuint32 tmp;           \
+                __asm__(                \
+                "mrs    %0, cpsr\n"     \
+                "orr    %1, %0, #64\n"  \
+                "msr    cpsr_c, %1\n"   \
+                : "=r" (x), "=r" (tmp)  \
+                :                       \
+                : "memory");            \
+        }
+
+/* 
+ * Restore the saved value back to CPSR register.
+ */
+#define gbus_restore_flags(x)                \
+        __asm__(                        \
+        "msr    cpsr_c, %0\n"           \
+        :                               \
+        : "r" (x))
+
+struct gbus_mutex;
+static inline void gbus_mutex_lock(struct gbus *pgbus, struct gbus_mutex *mutex)
+{
+	while (gbus_read_uint32(pgbus, (RMuint32) mutex));
+}
+
+static inline void gbus_mutex_unlock(struct gbus *pgbus, struct gbus_mutex *mutex)
+{
+	gbus_write_uint32(pgbus, (RMuint32) mutex, 0);
+}
+
+
+struct gbus_fifo {
+	RMuint32 base;
+	RMuint32 size;
+	RMuint32 rd;
+	RMuint32 wr;
+};
+
+struct gbus_fifo *gbus_fifo_open(struct gbus *pgbus, RMuint32 data_address, RMuint32 data_size, RMuint32 fifo_address);
+void gbus_fifo_get_pointer(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *base, RMuint32 *size, RMuint32 *rd_ptr, RMuint32 *wr_ptr);
+RMuint32 gbus_fifo_get_readable_size(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *rd_ptr1, RMuint32 *rd_size1, RMuint32 *rd_ptr2);
+RMuint32 gbus_fifo_get_writable_size(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 *wr_ptr1, RMuint32 *wr_size1, RMuint32 *wr_ptr2);
+RMuint32 gbus_fifo_incr_write_ptr(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 incr);
+RMuint32 gbus_fifo_incr_read_ptr(struct gbus *pgbus, struct gbus_fifo *fifo, RMuint32 incr);
+
+struct kc_tasklet_struct;
+void mumk_register_tasklet(struct gbus *pgbus, struct kc_tasklet_struct *tasklet, RMuint32 *irq_status, RMuint32 mask);
+void mumk_unregister_tasklet(struct gbus *pgbus, struct kc_tasklet_struct *kctasklet);
+
+
+#endif // __EMHWLIB_H__
diff -Naur linux.org/drivers/net/gnet/gnet_k.c linux.patched/drivers/net/gnet/gnet_k.c
--- linux.org/drivers/net/gnet/gnet_k.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/gnet_k.c	2005-07-29 10:11:27.450058790 +0200
@@ -0,0 +1,45 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+#include "kernelheaders.h"
+#include "common.h"
+
+// to enable or disable the debug messages of this source file, put 1 or 0 below
+#if 0
+#define LOCALDBG ENABLE
+#else
+#define LOCALDBG DISABLE
+#endif
+
+int gnetk_init(struct gnetprivate *pG,struct gbus *pgbus,struct gbus_fifo *rxfifo,struct gbus_fifo *txfifo)
+{       
+	PG_RMDBGLOG((LOCALDBG,"gnetk_init: begun\n"));
+	
+	memset(pG,0,sizeof(struct gnetprivate));
+
+	pG->pgbus=pgbus;
+	pG->rxfifo=rxfifo;
+	pG->txfifo=txfifo;
+
+	if (net_init(pG)==0) 
+		register_netdev(&pG->netdev);
+	else 
+		return -1;
+
+	PG_RMDBGLOG((LOCALDBG,"gnetk_init: done\n"));
+	
+	return 0;
+}
+
+void gnetk_cleanup(struct gnetprivate *pG)
+{
+        PG_RMDBGLOG((LOCALDBG,"gnetk_cleanup: begun\n"));
+
+	if (pG->netdev.name[0]!=0) 
+		unregister_netdev(&pG->netdev);
+	
+        PG_RMDBGLOG((LOCALDBG,"gnetk_cleanup: done\n"));
+}
diff -Naur linux.org/drivers/net/gnet/gnet_k.h linux.patched/drivers/net/gnet/gnet_k.h
--- linux.org/drivers/net/gnet/gnet_k.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/gnet_k.h	2005-07-29 10:11:27.401065556 +0200
@@ -0,0 +1,22 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   gnet_k.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2002-11-13
+*/
+
+#ifndef __GNET_K_H__
+#define __GNET_K_H__
+
+int gnetk_init(struct gnetprivate *pG,struct gbus *pgbus,struct gbus_fifo *rxfifo,struct gbus_fifo *txfifo);
+void gnetk_cleanup(struct gnetprivate *pG);
+
+#endif // __GNET_K_H__
diff -Naur linux.org/drivers/net/gnet/kernelheaders.h linux.patched/drivers/net/gnet/kernelheaders.h
--- linux.org/drivers/net/gnet/kernelheaders.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/kernelheaders.h	2005-07-29 10:11:27.414063761 +0200
@@ -0,0 +1,62 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   kernelheaders.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2002-12-03
+*/
+
+#ifndef __KERNELHEADERS_H__
+#define __KERNELHEADERS_H__
+
+#if (defined EM86XX_MODE) && (EM86XX_MODE == EM86XX_MODEID_STANDALONE)
+/*
+  RMuint32 and such types are present in the kernel headers already
+  protected by __RMBTYPES_H__
+  hack: clean this definitely by the inclusion of rmdef in kernel.
+ */
+#define ALLOW_OS_CODE 1
+#include "../rmdef/rmdef.h"
+#endif
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/devfs_fs_kernel.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/param.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <asm/checksum.h>
+
+#endif // __KERNELHEADERS_H__
diff -Naur linux.org/drivers/net/gnet/macros.h linux.patched/drivers/net/gnet/macros.h
--- linux.org/drivers/net/gnet/macros.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/macros.h	2005-07-29 10:11:27.415063623 +0200
@@ -0,0 +1,35 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   macros.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2002-11-13
+*/
+
+#ifndef __MACROS_H__
+#define __MACROS_H__
+
+#define FREQ (HZ/50)
+
+extern int logboard;
+#define PG_RMDBGLOG(x)					\
+do {							\
+	logboard=pG-Gtable; 				\
+	RMDBGLOG(x);					\
+	logboard=-1; 					\
+} while (0)
+#define PG_RMDBGPRINT(x)					\
+do {							\
+	logboard=pG-Gtable; 				\
+	RMDBGPRINT(x);					\
+	logboard=-1; 					\
+} while (0)
+
+#endif // __MACROS_H__
diff -Naur linux.org/drivers/net/gnet/minor.h linux.patched/drivers/net/gnet/minor.h
--- linux.org/drivers/net/gnet/minor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/minor.h	2005-07-29 10:11:27.415063623 +0200
@@ -0,0 +1,33 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+/**
+  @file   minor.h
+  See licensing details in LICENSING file  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2001-12-10
+*/
+
+#ifndef __MINOR_H__
+#define __MINOR_H__
+
+struct gnetprivate {
+	struct llad *pllad;
+	struct gbus *pgbus;
+
+	struct net_device netdev;
+	struct net_device_stats netstats;
+
+	struct gbus_fifo *rxfifo,*txfifo;
+	int csumerrors;
+};
+
+extern struct gnetprivate Gtable[2];
+
+#endif // __MINOR_H__
diff -Naur linux.org/drivers/net/gnet/net.c linux.patched/drivers/net/gnet/net.c
--- linux.org/drivers/net/gnet/net.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/net.c	2005-07-29 10:11:27.473055614 +0200
@@ -0,0 +1,401 @@
+/*****************************************
+ Copyright © 2001-2003	
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+/*
+  @file   net.c
+  See licensing details in LICENSING file  
+*/
+
+#include "kernelheaders.h"
+#include "common.h"
+
+// to enable or disable the debug messages of this source file, put 1 or 0 below
+#if 0
+#define LOCALDBG ENABLE
+#else
+#define LOCALDBG DISABLE
+#endif
+
+void gnet_tasklet(unsigned long cookie)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)cookie;
+	RMuint32 rxcount=0;
+	
+ 	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_PD10:GBUS_LOGGER_PD01,0);
+ 	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_RX0:GBUS_LOGGER_RX1,1);
+
+	while (1) {
+		RMuint32 ptr1;
+		RMuint32 size1;
+		RMuint32 ptr2;
+		RMuint32 size;
+		RMuint32 blocklen;
+		
+		RMuint32 len;
+		struct sk_buff *skb;
+		RMuint8 *dst;
+		
+		size=gbus_fifo_get_readable_size(pG->pgbus,pG->rxfifo,&ptr1,&size1,&ptr2);
+
+		/* tries to read gnet header */
+		if (size<4) 
+			break;
+		else {
+			len=gbus_read_uint32(pG->pgbus,ptr1);
+		}
+		
+		/* blocklen is always a multiple of 4 bytes */
+		blocklen=(4+len+3) & ~3;
+		
+		if (size<blocklen) {
+			PG_RMDBGLOG((ENABLE,"gnet_tasklet: algorithmic fifo error (rxcount=%d size=%d len=%d blocklen=%d)\n",
+				     rxcount,size,len,blocklen));
+			break;
+		}
+		
+		ptr1+=4;
+		size1-=4;
+
+		/* allocates 2 bytes more (skipped bytes) */
+		skb=dev_alloc_skb(len+2);
+		if (skb == NULL) {
+			pG->netstats.rx_dropped++;
+			
+			PG_RMDBGLOG((LOCALDBG,"gnet_tasklet: memory squeeze (dropped %d)\n",pG->netstats.rx_dropped));
+			break;
+		}
+
+		/* skip 2 bytes so that IP is aligned on 16 Bytes boundary */
+		skb_reserve(skb,2);
+
+		/* prepare skb to receive len bytes */
+		dst = skb_put(skb,len);
+		
+		while (len > 0) {
+			RMuint32 xfer_size;
+			
+			if (size1 == 0) {
+				size1 = len;
+				ptr1 = ptr2;
+			}
+			
+			xfer_size = RMmin(len, size1);
+			gbus_read_data8(pG->pgbus, ptr1, dst, xfer_size);
+			
+			dst += xfer_size;
+			len -= xfer_size;
+			size1 -= xfer_size;
+		}
+
+		gbus_fifo_incr_read_ptr(pG->pgbus,pG->rxfifo,blocklen);
+		
+		skb->dev = &pG->netdev;
+		skb->protocol = eth_type_trans(skb,&pG->netdev);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		pG->netdev.last_rx = jiffies;
+		pG->netstats.rx_bytes += skb->len;
+		pG->netstats.rx_packets++;
+		netif_rx(skb);
+		
+		PG_RMDBGLOG((LOCALDBG,"gnet_tasklet: rx skb 0x%08lx\n",skb));
+		
+		rxcount++;
+		
+		{
+			RMuint32 pending;
+
+			pending=gbus_read_uint32(pG->pgbus,(which==0)?RXC0:RXC1);
+			gbus_write_uint32(pG->pgbus,(which==0)?RXC0:RXC1,pending+1);
+		}
+	}
+	
+	PG_RMDBGLOG((DISABLE,"gnet_tasklet: %d skb's processed\n",rxcount));
+
+	gbus_logger(pG->pgbus,GBUS_LOGGER_COUNTER0,gbus_read_uint32(pG->pgbus,TXC0)-gbus_read_uint32(pG->pgbus,RXC1));
+	gbus_logger(pG->pgbus,GBUS_LOGGER_COUNTER1,gbus_read_uint32(pG->pgbus,TXC1)-gbus_read_uint32(pG->pgbus,RXC0));
+
+	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_RX0:GBUS_LOGGER_RX1,0);
+	return;
+}
+
+static int gnet_header(struct sk_buff *skb, struct net_device *dev,
+                unsigned short type, void *daddr, void *saddr,
+		       unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);
+	struct gnetprivate *pG=(struct gnetprivate *)dev->priv;
+	
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, saddr ? saddr : dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest,   daddr ? daddr : dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN-1]   = 1-(pG-Gtable);
+	PG_RMDBGLOG((DISABLE,"gnet_header: s=%02x:%02x:%02x:%02x:%02x:%02x d=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		     eth->h_source[0],
+		     eth->h_source[1],
+		     eth->h_source[2],
+		     eth->h_source[3],
+		     eth->h_source[4],
+		     eth->h_source[5],
+		     eth->h_dest[0],
+		     eth->h_dest[1],
+		     eth->h_dest[2],
+		     eth->h_dest[3],
+		     eth->h_dest[4],
+		     eth->h_dest[5]));
+
+	return (dev->hard_header_len);
+}
+
+static int gnet_tx_packet(struct sk_buff *skb, struct net_device *dev)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)dev->priv;
+	int rc;
+	RMuint32 flags;
+	RMuint32 ptr1;
+	RMuint32 size1;
+	RMuint32 ptr2;
+	RMuint32 size;
+
+	RMuint32 blocklen, len;
+	RMuint8 *src;
+	
+	save_flags(flags); cli();
+	
+	gbus_logger(pG->pgbus,GBUS_LOGGER_COUNTER0,gbus_read_uint32(pG->pgbus,TXC0)-gbus_read_uint32(pG->pgbus,RXC1));
+	gbus_logger(pG->pgbus,GBUS_LOGGER_COUNTER1,gbus_read_uint32(pG->pgbus,TXC1)-gbus_read_uint32(pG->pgbus,RXC0));
+	
+	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_TX0:GBUS_LOGGER_TX1,1);
+	
+	if (skb==NULL) {
+		PG_RMDBGLOG((LOCALDBG,"gnet_tx_packet: skb==NULL!\n"));
+		rc=0;
+		goto out;
+	}
+	
+	/* blocklen is (data length + gnet header length) + padding size to align on 4 bytes boundary */
+	blocklen = (skb->len + 4 + 3) & ~3;
+
+	size=gbus_fifo_get_writable_size(pG->pgbus,pG->txfifo,&ptr1,&size1,&ptr2);
+	
+	if (size<blocklen) {
+		PG_RMDBGLOG((LOCALDBG,"gnet_tx_packet: not enough room, rejecting 0x%08lx\n",skb));
+		rc=1;
+		goto out;
+	}
+
+	dev->trans_start = jiffies;
+		
+	if (which==2) {
+		// kind of trick when two interfaces sit on the same host ;-)
+		
+		struct iphdr *ih;
+		u32 *saddr, *daddr;
+		
+		// perform some changes
+		ih = (struct iphdr *)(skb->data+sizeof(struct ethhdr));
+		saddr = &ih->saddr;
+		daddr = &ih->daddr;
+		PG_RMDBGLOG((LOCALDBG,"gnet_tx_packet: from %d.%d.%d.%d to %d.%d.%d.%d\n",
+			     (int)((u8 *)saddr)[0],
+			     (int)((u8 *)saddr)[1],
+			     (int)((u8 *)saddr)[2],
+			     (int)((u8 *)saddr)[3],
+			     (int)((u8 *)daddr)[0],
+			     (int)((u8 *)daddr)[1],
+			     (int)((u8 *)daddr)[2],
+			     (int)((u8 *)daddr)[3]));
+		((u8 *)saddr)[2] = 1-((u8 *)saddr)[2];
+		((u8 *)daddr)[2] = 1-((u8 *)daddr)[2];
+		
+		ih->check = 0;         /* and rebuild the checksum (ip needs it) */
+		ih->check = ip_fast_csum((unsigned char *)ih,ih->ihl);
+	}
+
+	len = skb->len;
+	src = skb->data;
+	
+	/* writes gnet header */
+	gbus_write_uint32(pG->pgbus, ptr1, len);
+	ptr1 += 4;
+	size1 -= 4;
+	
+	while (len > 0) {
+		RMuint32 xfer_size;
+		
+		if (size1 == 0) {
+			size1 = len;
+			ptr1 = ptr2;
+		}
+		
+		xfer_size = RMmin(len, size1);
+		gbus_write_data8(pG->pgbus, ptr1, src, xfer_size);
+		
+		src += xfer_size;
+		len -= xfer_size;
+		size1 -= xfer_size;
+	}
+	
+	gbus_fifo_incr_write_ptr(pG->pgbus,pG->txfifo,blocklen);
+
+	pG->netstats.tx_bytes += skb->len;
+	pG->netstats.tx_packets++;
+	dev_kfree_skb(skb);
+	
+	PG_RMDBGLOG((LOCALDBG,"gnet_tx_packet: tx skb 0x%08lx\n",skb));
+	
+	{
+		RMuint32 pending;
+		
+		pending=gbus_read_uint32(pG->pgbus,(which==0)?TXC0:TXC1);
+		gbus_write_uint32(pG->pgbus,(which==0)?TXC0:TXC1,pending+1);
+	}
+	
+	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_PD01:GBUS_LOGGER_PD10,1);
+	
+	// raise interrupt
+	switch (which) {
+	case 0: // uclinux
+		RMASSERT(pG==Gtable);
+#if ((EM86XX_CHIP==EM86XX_CHIPID_MAMBO) || (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT))
+		gbus_write_uint32(pG->pgbus, REG_BASE_host_interface+PCI_IRQ,
+				  LLAD_GNET1RX);
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT) || (EM86XX_CHIP==EM86XX_CHIPID_TANGO15) || (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+		gbus_write_uint32(pG->pgbus, REG_BASE_host_interface+PCI_irq_set,
+				  LLAD_GNET1RX);
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to emhwlib/include/emhwlib_chips.h.
+#endif
+		break;
+		
+	case 1: // host
+		RMASSERT(pG==Gtable+1);
+		gbus_mutex_lock(pG->pgbus, SOFT_IRQ_MUTEX_IRQ);
+		gbus_mutex_lock(pG->pgbus, SOFT_IRQ_MUTEX_FIQ);
+		gbus_write_uint32(pG->pgbus, HOST_INTERRUPT_STATUS,
+				  LLAD_GNET0RX);
+		gbus_write_uint32(pG->pgbus, REG_BASE_cpu_block+CPU_irq_softset,
+				  SOFT_IRQ_ORIGIN_PT110);
+		gbus_mutex_unlock(pG->pgbus, SOFT_IRQ_MUTEX_FIQ);
+		gbus_mutex_unlock(pG->pgbus, SOFT_IRQ_MUTEX_IRQ);
+		break;
+		
+	case 2: // both interfaces on uclinux or host
+#if (EM86XX_MODE==EM86XX_MODEID_WITHHOST) 
+		
+		// can't use gbus_set_interrupt because mutex is taken twice
+#if ((EM86XX_CHIP==EM86XX_CHIPID_MAMBO) || (EM86XX_CHIP==EM86XX_CHIPID_MAMBOLIGHT))
+		gbus_write_uint32(pG->pgbus, REG_BASE_host_interface+PCI_IRQ,
+				  (pG==Gtable)?LLAD_GNET1RX:LLAD_GNET0RX);
+#elif (EM86XX_CHIP==EM86XX_CHIPID_TANGOLIGHT) || (EM86XX_CHIP==EM86XX_CHIPID_TANGO15) || (EM86XX_CHIP==EM86XX_CHIPID_TANGO2)
+		gbus_write_uint32(pG->pgbus, REG_BASE_host_interface+PCI_irq_set,
+				  (pG==Gtable)?LLAD_GNET1RX:LLAD_GNET0RX);
+#else
+#error EM86XX_CHIP is not set in RMCFLAGS: refer to emhwlib/include/emhwlib_chips.h.
+#endif
+		
+#elif (EM86XX_MODE==EM86XX_MODEID_STANDALONE)
+		gbus_mutex_lock(pG->pgbus, SOFT_IRQ_MUTEX_IRQ);
+		gbus_mutex_lock(pG->pgbus, SOFT_IRQ_MUTEX_FIQ);
+		// can't use gbus_set_interrupt because undef is not handled in kernel mode
+		gbus_write_uint32(pG->pgbus, HOST_INTERRUPT_STATUS,
+				  (pG==Gtable)?LLAD_GNET1RX:LLAD_GNET0RX);
+		gbus_write_uint32(pG->pgbus, REG_BASE_cpu_block+CPU_irq_softset,
+				  SOFT_IRQ_ORIGIN_PT110);
+		gbus_mutex_unlock(pG->pgbus, SOFT_IRQ_MUTEX_FIQ);
+		gbus_mutex_unlock(pG->pgbus, SOFT_IRQ_MUTEX_IRQ);
+#else //EM86XX_MODE
+		NOTCOMPILABLE;
+#endif //EM86XX_MODE
+	default:
+		break;
+	}
+	
+	gbus_logger(pG->pgbus,(which==0)?GBUS_LOGGER_TX0:GBUS_LOGGER_TX1,0);
+
+	rc=0;
+
+ out:
+	restore_flags(flags);
+	return rc;
+}
+
+static int gnet_open(struct net_device *dev)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)dev->priv;
+
+	MOD_INC_USE_COUNT;
+
+	PG_RMDBGLOG((LOCALDBG,"gnet_open: begun\n"));
+	
+	// mac address 00:07:07:07:07:last-digit-of-uclinux-ip:index
+
+	/*
+	  ANY CHANGE OF MAC ADDRESS OF THE SAME IP INTERFACE WILL CAUSE 
+	  MAJOR PROBLEMS SINCE THE PREVIOUS ONE HAS BEEN CACHED BY ALL COMPUTERS OF THE LAN
+	 */
+	*(dev->dev_addr)=0;
+	memset(dev->dev_addr+1, 0x07, ETH_ALEN-3);
+	*(dev->dev_addr+ETH_ALEN-2)=gbus_read_uint8(pG->pgbus, REG_BASE_cpu_block+LR_GNET_MAC);
+	*(dev->dev_addr+ETH_ALEN-1)=pG-Gtable;
+
+	memset(&pG->netstats,0,sizeof(struct net_device_stats));
+
+	netif_start_queue(dev);
+
+	PG_RMDBGLOG((LOCALDBG,"gnet_open: done\n"));
+
+	return 0;
+}
+
+static int gnet_close(struct net_device *dev)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)dev->priv;
+
+	PG_RMDBGLOG((LOCALDBG,"gnet_close: begun\n"));
+
+	netif_stop_queue (dev);
+
+	PG_RMDBGLOG((LOCALDBG,"gnet_close: done\n"));
+
+	MOD_DEC_USE_COUNT;
+
+	return 0;
+}
+
+static struct net_device_stats *gnet_get_stats(struct net_device *dev)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)dev->priv;
+
+	return &pG->netstats;
+}
+
+int net_init(struct gnetprivate *pG)
+{
+	struct net_device *dev=&pG->netdev;
+
+	PG_RMDBGLOG((LOCALDBG,"net_init: begun\n"));
+
+	SET_MODULE_OWNER(dev);
+	
+	memset(dev,0,sizeof(struct net_device));
+
+	sprintf(dev->name,"gnet%ld",pG-Gtable);
+	
+	ether_setup(dev);
+	dev->hard_start_xmit	 = gnet_tx_packet;
+	dev->open		 = gnet_open;
+	dev->stop		 = gnet_close;
+	dev->get_stats 		 = gnet_get_stats;
+	dev->hard_header         = gnet_header;
+	dev->hard_header_cache = NULL;      /* Disable caching */
+	dev->flags	         |= IFF_NOARP|IFF_POINTOPOINT;
+	//	dev->tx_queue_len = 100;
+
+	dev->priv = pG;
+	PG_RMDBGLOG((LOCALDBG,"net_init: done\n"));
+
+	return 0;
+}
diff -Naur linux.org/drivers/net/gnet/net.h linux.patched/drivers/net/gnet/net.h
--- linux.org/drivers/net/gnet/net.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/net.h	2005-07-29 10:11:27.415063623 +0200
@@ -0,0 +1,22 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   net.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2003-09-05
+*/
+
+#ifndef __NET_H__
+#define __NET_H__
+
+int net_init(struct gnetprivate *pG);
+void gnet_tasklet(unsigned long cookie);
+
+#endif // __NET_H__
diff -Naur linux.org/drivers/net/gnet/probe.c linux.patched/drivers/net/gnet/probe.c
--- linux.org/drivers/net/gnet/probe.c	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/probe.c	2005-07-29 10:11:27.473055614 +0200
@@ -0,0 +1,121 @@
+/*****************************************
+ Copyright © 2001-2003	
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+/*
+  @file   probe.c
+  See licensing details in LICENSING file  
+*/
+
+#include "kernelheaders.h"
+#include "common.h"
+
+// to enable or disable the debug messages of this source file, put 1 or 0 below
+#if 1
+#define LOCALDBG ENABLE
+#else
+#define LOCALDBG DISABLE
+#endif
+
+#if defined(CONFIG_TANGO2_XENV)
+extern int tango2_gnet_enabled(void); 
+#endif
+
+int number_of_probed_gnets;
+struct gnetprivate Gtable[2];
+
+MODULE_DESCRIPTION("gbus network driver");
+MODULE_AUTHOR("Emmanuel Michon <emmanuel_michon@gnet.fr>");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Proprietary");  // parsed keyword, don't change!
+#endif // MODULE_LICENSE
+
+#ifdef CONFIG_GNET
+int which=0;
+#else
+int which=-1; // 0: probe first (uclinux side). 1: probe second (host side). 2: probe both on uclinux / both on host
+#endif
+
+MODULE_PARM(which,"i");
+
+static RMuint32 mask=0;
+static struct gbus *pgbus;
+static unsigned long master_status;
+static struct tasklet_struct master_tasklet;
+
+static void master_routine(unsigned long cookie)
+{
+	struct gnetprivate *pG=(struct gnetprivate *)cookie;
+
+	if (master_status&LLAD_GNET0RX) 
+		gnet_tasklet((unsigned long)pG);
+	
+	if (master_status&LLAD_GNET1RX) 
+		gnet_tasklet((unsigned long)(pG+1));
+}
+
+static int __init gnet_init_module(void)
+{  
+	struct gbus_fifo *f0,*f1;
+
+#if defined(CONFIG_TANGO2_XENV)
+	if (tango2_gnet_enabled() == 0) 
+		return 0;
+#endif
+	RMDBGLOG((LOCALDBG,"init_module: begun\n"));
+	
+	if (which==-1) return -EINVAL;
+
+	pgbus=gbus_open(llad_open("0"));
+	gbus_write_uint32(pgbus,TXC0,0);
+	gbus_write_uint32(pgbus,TXC1,0);
+	gbus_write_uint32(pgbus,RXC0,0);
+	gbus_write_uint32(pgbus,RXC1,0);
+	f0=gbus_fifo_open(pgbus,F0DATA,DATALEN,F0);
+	f1=gbus_fifo_open(pgbus,F1DATA,DATALEN,F1);
+
+	if (which!=1) {
+		mask|=LLAD_GNET0RX;
+		gnetk_init(&Gtable[0],pgbus,f0,f1);
+		number_of_probed_gnets++;
+	}
+	if (which!=0) {
+		mask|=LLAD_GNET1RX;
+		gnetk_init(&Gtable[1],pgbus,f1,f0);
+		number_of_probed_gnets++;
+	}
+	
+	tasklet_init(&master_tasklet,master_routine,(unsigned long)Gtable);
+	mumk_register_tasklet(pgbus,(struct kc_tasklet_struct *)&master_tasklet,&master_status, (LLAD_GNET0RX|LLAD_GNET1RX));
+	
+	RMDBGLOG((ENABLE,"init_module: found %d interface%s, done\n",
+		  number_of_probed_gnets,
+		  (number_of_probed_gnets>1)?"s":""));
+	
+	return 0;
+}
+
+static void __exit gnet_cleanup_module(void)
+{
+#if defined(CONFIG_TANGO2_XENV)
+	if (tango2_gnet_enabled() == 0) 
+		return;
+#endif
+	RMDBGLOG((LOCALDBG,"cleanup_module: begun\n"));
+
+	tasklet_disable(&master_tasklet);
+	mumk_unregister_tasklet(pgbus,(struct kc_tasklet_struct *)&master_tasklet);
+	
+	if (which!=1) gnetk_cleanup(&Gtable[0]);
+	if (which!=0) gnetk_cleanup(&Gtable[1]);
+	number_of_probed_gnets=0;
+	
+	// hack: should call gbus_fifo_close here.
+	
+	RMDBGLOG((ENABLE,"cleanup_module: done\n"));
+}
+
+module_init(gnet_init_module);
+module_exit(gnet_cleanup_module);
diff -Naur linux.org/drivers/net/gnet/probe.h linux.patched/drivers/net/gnet/probe.h
--- linux.org/drivers/net/gnet/probe.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/probe.h	2005-07-29 10:11:27.415063623 +0200
@@ -0,0 +1,47 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+
+/**
+  @file   probe.h
+  See licensing details in LICENSING file  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2001-12-10
+*/
+
+#ifndef __PROBE_H__
+#define __PROBE_H__
+
+extern int number_of_probed_gnets;
+extern int which;
+
+#ifndef FM_GNET
+#warning 8620 kernel patch dram map inaccurate --- hack: fixing
+#define FM_GNET FM_DRM
+#endif
+
+#define TXC0 (MEM_BASE_dram_controller_0+FM_GNET)
+#define TXC1 (TXC0+4)
+#define RXC0 (TXC1+4)
+#define RXC1 (RXC0+4)
+#define F0   (RXC1+4)
+
+#define F0DATA (F0+sizeof(struct gbus_fifo))
+#define F1 (F0DATA+DATALEN)
+#define F1DATA (F1+sizeof(struct gbus_fifo))
+
+// keep data len multiple of 4 so that we can transfer with gbus_read/write_uint32
+#if (EM86XX_CHIP>=EM86XX_CHIPID_TANGO2)
+#define DATALEN 1900
+RMleftMustBeSmaller(F1DATA+DATALEN,MEM_BASE_dram_controller_0+FM_SCRATCH,seed10);
+#else
+#define DATALEN (16*1022)
+RMleftMustBeSmaller(F1DATA+DATALEN,MEM_BASE_dram_controller_0+FM_BOOTLOADER_CODE,seed10);
+#endif
+
+#endif // __PROBE_H__
diff -Naur linux.org/drivers/net/gnet/tango2/emhwlib_registers_tango2.h linux.patched/drivers/net/gnet/tango2/emhwlib_registers_tango2.h
--- linux.org/drivers/net/gnet/tango2/emhwlib_registers_tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/tango2/emhwlib_registers_tango2.h	2005-07-29 10:11:27.485053957 +0200
@@ -0,0 +1,1214 @@
+/******************************************************/
+/* This file is generated automatically, DO NOT EDIT! */
+/******************************************************/
+/*
+ * ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+ *
+ * Copyright (c) 2001-2003 Sigma Designs, Inc. 
+ * All Rights Reserved. Proprietary and Confidential.
+ *
+ */
+ 
+/**
+  @file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h
+  @brief emhwlib generated file
+   
+  @author Jacques Mahe, Christian Wolff, Julien Soulier, Emmanuel Michon
+  @ingroup hwlproperties
+*/
+
+#ifndef __EMHWLIB_REGISTERS_TANGO2_H__
+#define __EMHWLIB_REGISTERS_TANGO2_H__
+
+/* SystemBlock registers */
+#define REG_BASE_system_block 0x00010000 /* width RMuint32 */
+#define SYS_clkgen0_pll 0x0000 /* width RMuint32 */
+#define SYS_clkgen0_div 0x0004 /* width RMuint32 */
+#define SYS_clkgen1_pll 0x0008 /* width RMuint32 */
+#define SYS_clkgen1_div 0x000C /* width RMuint32 */
+#define SYS_clkgen2_pll 0x0010 /* width RMuint32 */
+#define SYS_clkgen2_div 0x0014 /* width RMuint32 */
+#define SYS_clkgen3_pll 0x0018 /* width RMuint32 */
+#define SYS_clkgen3_div 0x001C /* width RMuint32 */
+#define SYS_avclk_mux 0x0038 /* width RMuint32 */
+#define SYS_sysclk_mux 0x003C /* width RMuint32 */
+#define SYS_clk_cnt 0x0040 /* width RMuint32 */
+#define SYS_xtal_in_cnt 0x0048 /* width RMuint32 */
+#define SYS_hostclk_mux 0x0030 /* width RMuint32 */
+#define SYS_sysclk_premux 0x0034 /* width RMuint32 */
+#define SYS_rnd_cnt 0x0044 /* width RMuint32 */
+#define SYS_cnt_cfg 0x004c /* width RMuint32 */
+#define SYS_cfg_cnt0 0x0050 /* width RMuint32 */
+#define SYS_cfg_cnt1 0x0054 /* width RMuint32 */
+#define SYS_cfg_cnt2 0x0058 /* width RMuint32 */
+#define SYS_cfg_cnt3 0x005c /* width RMuint32 */
+#define SYS_cfg_cnt4 0x0060 /* width RMuint32 */
+#define SYS_cleandiv0_div 0x0080 /* width RMuint32 */
+#define SYS_cleandiv1_div 0x0088 /* width RMuint32 */
+#define SYS_cleandiv2_div 0x0090 /* width RMuint32 */
+#define SYS_cleandiv4_div 0x00a0 /* width RMuint32 */
+#define SYS_cleandiv5_div 0x00a8 /* width RMuint32 */
+#define SYS_cleandiv6_div 0x00b0 /* width RMuint32 */
+#define SYS_cleandiv7_div 0x00b8 /* width RMuint32 */
+#define SYS_cleandiv8_div 0x00c0 /* width RMuint32 */
+#define SYS_cleandiv9_div 0x00c8 /* width RMuint32 */
+#define SYS_cleandiv10_div 0x00d0 /* width RMuint32 */
+#define MARB_mid01_cfg 0x0200 /* width RMuint32 */
+#define MARB_mid21_cfg 0x0204 /* width RMuint32 */
+#define MARB_mid02_cfg 0x0208 /* width RMuint32 */
+#define MARB_mid22_cfg 0x020c /* width RMuint32 */
+#define MARB_mid04_cfg 0x0210 /* width RMuint32 */
+#define MARB_mid24_cfg 0x0214 /* width RMuint32 */
+#define MARB_mid25_cfg 0x0218 /* width RMuint32 */
+#define MARB_mid08_cfg 0x021c /* width RMuint32 */
+#define MARB_mid28_cfg 0x0220 /* width RMuint32 */
+#define MARB_mid29_cfg 0x0224 /* width RMuint32 */
+#define MARB_mid0C_cfg 0x0228 /* width RMuint32 */
+#define MARB_mid2C_cfg 0x022c /* width RMuint32 */
+#define MARB_mid10_cfg 0x0230 /* width RMuint32 */
+#define MARB_mid30_cfg 0x0234 /* width RMuint32 */
+#define MARB_mid31_cfg 0x0238 /* width RMuint32 */
+#define MARB_mid12_cfg 0x023c /* width RMuint32 */
+#define MARB_mid32_cfg 0x0240 /* width RMuint32 */
+#define VARB_mid01_cfg 0x0300 /* width RMuint32 */
+#define VARB_mid02_cfg 0x0304 /* width RMuint32 */
+#define VARB_mid21_cfg 0x0308 /* width RMuint32 */
+#define VARB_mid22_cfg 0x030c /* width RMuint32 */
+#define VARB_mid23_cfg 0x0310 /* width RMuint32 */
+#define VARB_mid24_cfg 0x0314 /* width RMuint32 */
+#define VARB_mid25_cfg 0x0318 /* width RMuint32 */
+#define VARB_mid26_cfg 0x031c /* width RMuint32 */
+#define VARB_mid27_cfg 0x0320 /* width RMuint32 */
+#define VARB_mid28_cfg 0x0324 /* width RMuint32 */
+#define VARB_mid29_cfg 0x0328 /* width RMuint32 */
+#define VARB_mid2A_cfg 0x032c /* width RMuint32 */
+#define VARB_mid10_cfg 0x0330 /* width RMuint32 */
+#define VARB_mid30_cfg 0x0334 /* width RMuint32 */
+#define VARB_mid31_cfg 0x0338 /* width RMuint32 */
+#define IARB_mid01_cfg 0x0400 /* width RMuint32 */
+#define IARB_mid02_cfg 0x0404 /* width RMuint32 */
+#define SYS_gpio_dir 0x0500 /* width RMuint32 */
+#define SYS_gpio_data 0x0504 /* width RMuint32 */
+#define SYS_gpio_int 0x0508 /* width RMuint32 */
+#define SYS_gpio15_pwm 0x0510 /* width RMuint32 */
+#define SYS_gpio14_pwm 0x0514 /* width RMuint32 */
+#define REG_BASE_dram_controller_0 0x00030000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_0 0x10000000 /* width RMuint32 */
+#define REG_BASE_dram_controller_1 0x00040000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_1 0x20000000 /* width RMuint32 */
+#define REG_BASE_dram_controller_2 0x00050000 /* width RMuint32 */
+#define MEM_BASE_dram_controller_2 0x30000000 /* width RMuint32 */
+#define DRAM_dunit_cfg 0x0000 /* width RMuint32 */
+#define DRAM_dunit_delay0_ctrl 0x0004 /* width RMuint32 */
+#define DRAM_dunit_delay1_ctrl 0x0008 /* width RMuint32 */
+#define DRAM_dunit_auto_delay 0x000c /* width RMuint32 */
+#define DRAM_dunit_delay_probe 0x0010 /* width RMuint32 */
+#define DRAM_dunit_effective_delay 0x0014 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cfg 0x0020 /* width RMuint32 */
+#define DRAM_dunit_bw_probe_cnt 0x0024 /* width RMuint32 */
+#define DRAM_dunit_flush_buffer 0x0104 /* width RMuint32 */
+#define REG_BASE_host_interface 0x00020000 /* width RMuint32 */
+#define MEM_BASE_host_interface 0x40000000 /* width RMuint32 */
+#define IDE_data 0x0000 /* width RMuint32 */
+#define IDE_error 0x0004 /* width RMuint32 */
+#define IDE_count 0x0008 /* width RMuint32 */
+#define IDE_start_sector 0x000c /* width RMuint32 */
+#define IDE_cylinder_lo 0x0010 /* width RMuint32 */
+#define IDE_cylinder_hi 0x0014 /* width RMuint32 */
+#define IDE_head_device 0x0018 /* width RMuint32 */
+#define IDE_cmd_stat 0x001c /* width RMuint32 */
+#define IDE_irq_stat 0x0218 /* width RMuint32 */
+#define IDE_cmd_stat__ 0x021c /* width RMuint32 */
+#define PB_timing0 0x0800 /* width RMuint32 */
+#define PB_timing1 0x0804 /* width RMuint32 */
+#define PB_timing2 0x0808 /* width RMuint32 */
+#define PB_timing3 0x080c /* width RMuint32 */
+#define PB_timing4 0x0810 /* width RMuint32 */
+#define PB_timing5 0x0814 /* width RMuint32 */
+#define PB_default_timing 0x0818 /* width RMuint32 */
+#define PB_use_timing0 0x081c /* width RMuint32 */
+#define PB_use_timing1 0x0820 /* width RMuint32 */
+#define PB_use_timing2 0x0824 /* width RMuint32 */
+#define PB_use_timing3 0x0828 /* width RMuint32 */
+#define PB_use_timing4 0x082c /* width RMuint32 */
+#define PB_use_timing5 0x0830 /* width RMuint32 */
+#define PB_CS_config 0x0834 /* width RMuint32 */
+#define PB_automode_start_address 0x0840 /* width RMuint32 */
+#define PB_automode_control 0x0844 /* width RMuint32 */
+#define SFLA_status 0xa000 /* width RMuint32 */
+#define SFLA_read_parameters 0xa008 /* width RMuint32 */
+#define SFLA_drive_pads 0xa00c /* width RMuint32 */
+#define SFLA_driver_speed 0xa010 /* width RMuint32 */
+#define SFLA_N_for_Send_Get 0xa020 /* width RMuint32 */
+#define SFLA_read_data 0xa030 /* width RMuint32 */
+#define SFLA_Send_1 0xa040 /* width RMuint32 */
+#define SFLA_Send_8 0xa044 /* width RMuint32 */
+#define SFLA_Send_16 0xa048 /* width RMuint32 */
+#define SFLA_Send_32 0xa04c /* width RMuint32 */
+#define SFLA_Send_Get_1 0xa050 /* width RMuint32 */
+#define SFLA_Send_Get_8 0xa054 /* width RMuint32 */
+#define SFLA_Send_Get_16 0xa058 /* width RMuint32 */
+#define SFLA_Send_Get_32 0xa05c /* width RMuint32 */
+#define SFLA_Chip_Select 0xa060 /* width RMuint32 */
+#define SFLA_Chip_Deselect 0xa064 /* width RMuint32 */
+#define SFLA_Send_N 0xa068 /* width RMuint32 */
+#define SFLA_Get_SlaveOut 0xa070 /* width RMuint32 */
+#define SFLA_Wait_Timer 0xa074 /* width RMuint32 */
+#define SFLA_Send_Get_N 0xa078 /* width RMuint32 */
+#define EMHWLIB_IS_HOST 0xe000 /* width RMuint32 */
+#define HOST_REG1 0xfed0 /* width RMuint32 */
+#define HOST_REG2 0xfed4 /* width RMuint32 */
+#define READ_ADDRESS 0xfec0 /* width RMuint32 */
+#define READ_COUNTER 0xfec4 /* width RMuint32 */
+#define READ_ENABLE 0xfec8 /* width RMuint32 */
+#define READ_REVERSE 0xfecc /* width RMuint32 */
+#define WRITE_ADDRESS 0xfed8 /* width RMuint32 */
+#define WRITE_COUNTER 0xfedc /* width RMuint32 */
+#define WRITE_ENABLE 0xfee0 /* width RMuint32 */
+#define BURST 0xfee4 /* width RMuint32 */
+#define PCI_TIMEOUT 0x8000 /* width RMuint32 */
+#define PCI_TIMEOUT_STATUS 0x8004 /* width RMuint32 */
+#define PCI_TIMER 0x8008 /* width RMuint32 */
+#define PCI_TIMER_TEST 0x800c /* width RMuint32 */
+#define PCI_WAKEUP 0x8010 /* width RMuint32 */
+#define PCI_REGION_0_BASE 0x9000 /* width RMuint32 */
+#define PCI_REGION_1_BASE 0x9004 /* width RMuint32 */
+#define PCI_REGION_2_BASE 0x9008 /* width RMuint32 */
+#define PCI_REGION_3_BASE 0x900c /* width RMuint32 */
+#define PCI_REGION_4_BASE 0x9010 /* width RMuint32 */
+#define PCI_REGION_5_BASE 0x9014 /* width RMuint32 */
+#define PCI_REGION_6_BASE 0x9018 /* width RMuint32 */
+#define PCI_REGION_7_BASE 0x901c /* width RMuint32 */
+#define PCI_irq_status 0x9020 /* width RMuint32 */
+#define PCI_irq_set 0x9024 /* width RMuint32 */
+#define PCI_irq_clear 0x9028 /* width RMuint32 */
+#define SBOX_FIFO_RESET 0x90a0 /* width RMuint32 */
+#define SBOX_ROUTE 0x90a8 /* width RMuint32 */
+#define output_SBOX_MBUS_W0 0x9080 /* width RMuint32 */
+#define output_SBOX_MBUS_W1 0x9084 /* width RMuint32 */
+#define output_SBOX_PCI_MASTER 0x9088 /* width RMuint32 */
+#define output_SBOX_PCI_SLAVE 0x908c /* width RMuint32 */
+#define output_SBOX_CIPHER 0x9090 /* width RMuint32 */
+#define output_SBOX_IDE_ISA 0x9094 /* width RMuint32 */
+#define output_SBOX_IDE_DVD 0x9098 /* width RMuint32 */
+#define input_keep_SBOX 0 /* width RMuint32 */
+#define input_MBUS_R0_SBOX 1 /* width RMuint32 */
+#define input_MBUS_R1_SBOX 2 /* width RMuint32 */
+#define input_PCI_MASTER_SBOX 3 /* width RMuint32 */
+#define input_PCI_SLAVE_SBOX 4 /* width RMuint32 */
+#define input_CIPHER_SBOX 5 /* width RMuint32 */
+#define input_IDE_DVD_SBOX 6 /* width RMuint32 */
+#define input_IDE_ISA_SBOX 7 /* width RMuint32 */
+#define input_SFLA_SBOX 8 /* width RMuint32 */
+#define input_unconnected_SBOX 0xf /* width RMuint32 */
+#define host_mutex0 0x9040 /* width RMuint32 */
+#define host_mutex1 0x9044 /* width RMuint32 */
+#define host_mutex2 0x9048 /* width RMuint32 */
+#define host_mutex3 0x904c /* width RMuint32 */
+#define host_mutex4 0x9050 /* width RMuint32 */
+#define host_mutex5 0x9054 /* width RMuint32 */
+#define host_mutex6 0x9058 /* width RMuint32 */
+#define host_mutex7 0x905c /* width RMuint32 */
+#define host_mutex8 0x9060 /* width RMuint32 */
+#define host_mutex9 0x9064 /* width RMuint32 */
+#define host_mutex10 0x9068 /* width RMuint32 */
+#define host_mutex11 0x906c /* width RMuint32 */
+#define host_mutex12 0x9070 /* width RMuint32 */
+#define host_mutex13 0x9074 /* width RMuint32 */
+#define host_mutex14 0x9078 /* width RMuint32 */
+#define host_mutex15 0x907c /* width RMuint32 */
+#define PCI_host_reg5 0xfe94 /* width RMuint32 */
+#define PCI_chip_is_host 0xfe90 /* width RMuint32 */
+#define IDECTRL_idesrc 0x20d0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim1 0x20e0 /* width RMuint32 */
+#define IDECTRL_pri_drv1udmatim2 0x20f0 /* width RMuint32 */
+#define IDECTRL_pri_idectl 0x2100 /* width RMuint32 */
+#define IDECTRL_pri_drv0tim 0x2110 /* width RMuint32 */
+#define IDECTRL_pri_drv1tim 0x2120 /* width RMuint32 */
+#define IDECTRL_idemisc 0x2130 /* width RMuint32 */
+#define IDECTRL_idestatus 0x2140 /* width RMuint32 */
+#define IDECTRL_udmactl 0x2150 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim1 0x2160 /* width RMuint32 */
+#define IDECTRL_pri_drv0udmatim2 0x2170 /* width RMuint32 */
+#define IDECTRL_pref_st 0x2310 /* width RMuint32 */
+#define IDECTRL_pri_ctrlblock 0x2398 /* width RMuint32 */
+#define IDECTRL_pri_cmdblock 0x23c0 /* width RMuint32 */
+#define IDECTRL_bmic 0x2400 /* width RMuint32 */
+#define IDECTRL_bmis 0x2410 /* width RMuint32 */
+#define IDECTRL_bmidtp 0x2420 /* width RMuint32 */
+#define IDECTRL_ide_dmaptr 0x2780 /* width RMuint32 */
+#define IDECTRL_ide_dmalen 0x2790 /* width RMuint32 */
+#define IDECTRL_pio_prefetch_data 0x27c0 /* width RMuint32 */
+#define MEM_BASE_pfla 0x40000000 /* width RMuint32 */
+#define PB_CS0_OFFSET 0x00000000 /* width RMuint32 */
+#define PB_CS1_OFFSET 0x04000000 /* width RMuint32 */
+#define PB_CS2_OFFSET 0x08000000 /* width RMuint32 */
+#define PB_CS3_OFFSET 0x0c000000 /* width RMuint32 */
+#define PCI_host_reg1 0xfed0 /* width RMuint32 */
+#define PCI_host_reg2 0xfed4 /* width RMuint32 */
+#define PCI_host_reg3 0xfe80 /* width RMuint32 */
+#define PCI_host_reg4 0xfe84 /* width RMuint32 */
+#define PCI_pcictrl_reg1 0xfe88 /* width RMuint32 */
+#define PCI_pcictrl_reg2 0xfe8c /* width RMuint32 */
+#define PCI_pcictrl_reg3 0xfefc /* width RMuint32 */
+#define PCI_REG0 0xfee8 /* width RMuint32 */
+#define PCI_REG1 0xfeec /* width RMuint32 */
+#define PCI_REG2 0xfef0 /* width RMuint32 */
+#define PCI_REG3 0xfef4 /* width RMuint32 */
+#define PCI_CONFIG 0xfef8 /* width RMuint32 */
+#define MIF_W0_ADD 0xb000 /* width RMuint32 */
+#define MIF_W0_CNT 0xb004 /* width RMuint32 */
+#define MIF_W0_SKIP 0xb008 /* width RMuint32 */
+#define MIF_W0_CMD 0xb00c /* width RMuint32 */
+#define MIF_W1_ADD 0xb040 /* width RMuint32 */
+#define MIF_W1_CNT 0xb044 /* width RMuint32 */
+#define MIF_W1_SKIP 0xb048 /* width RMuint32 */
+#define MIF_W1_CMD 0xb04c /* width RMuint32 */
+#define MIF_R0_ADD 0xb080 /* width RMuint32 */
+#define MIF_R0_CNT 0xb084 /* width RMuint32 */
+#define MIF_R0_SKIP 0xb088 /* width RMuint32 */
+#define MIF_R0_CMD 0xb08c /* width RMuint32 */
+#define MIF_R1_ADD 0xb0c0 /* width RMuint32 */
+#define MIF_R1_CNT 0xb0c4 /* width RMuint32 */
+#define MIF_R1_SKIP 0xb0c8 /* width RMuint32 */
+#define MIF_R1_CMD 0xb0cc /* width RMuint32 */
+#define MBUS_IDLE 0 /* width RMuint32 */
+#define MBUS_LINEAR 1 /* width RMuint32 */
+#define MBUS_DOUBLE 2 /* width RMuint32 */
+#define MBUS_RECTANGLE 3 /* width RMuint32 */
+#define MBUS_VOID 4 /* width RMuint32 */
+#define MBUS_LINEAR_VOID 5 /* width RMuint32 */
+#define MBUS_DOUBLE_VOID 6 /* width RMuint32 */
+#define MBUS_RECTANGLE_VOID 7 /* width RMuint32 */
+#define MBUS_TILED 8 /* width RMuint32 */
+#define GBUS_MUTEX_XPU 0x14 /* width RMuint32 */
+#define GBUS_MUTEX_PT110 0x16 /* width RMuint32 */
+#define GBUS_MUTEX_TDMX 0x19 /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_0 0x1b /* width RMuint32 */
+#define GBUS_MUTEX_AUDIO_1 0x1c /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_0 0x1d /* width RMuint32 */
+#define GBUS_MUTEX_MPEG_1 0x1e /* width RMuint32 */
+#define GBUS_MUTEX_HOST 0x1f /* width RMuint32 */
+#define GBUS_MUTEX_LOCAL 0x10 /* width RMuint32 */
+/* SystemBlock registers done */
+
+/* CPUBlock registers */
+#define REG_BASE_cpu_block 0x00060000 /* width RMuint32 */
+#define CPU_time0_load 0xc500 /* width RMuint32 */
+#define CPU_time0_value 0xc504 /* width RMuint32 */
+#define CPU_time0_ctrl 0xc508 /* width RMuint32 */
+#define CPU_time0_clr 0xc50c /* width RMuint32 */
+#define CPU_time1_load 0xc600 /* width RMuint32 */
+#define CPU_time1_value 0xc604 /* width RMuint32 */
+#define CPU_time1_ctrl 0xc608 /* width RMuint32 */
+#define CPU_time1_clr 0xc60c /* width RMuint32 */
+#define CPU_rtc_data 0xc800 /* width RMuint32 */
+#define CPU_rtc_match 0xc804 /* width RMuint32 */
+#define CPU_rtc_stat 0xc808 /* width RMuint32 */
+#define CPU_rtc_load 0xc80c /* width RMuint32 */
+#define CPU_rtc_ctrl 0xc810 /* width RMuint32 */
+#define CPU_irq_status 0xe000 /* width RMuint32 */
+#define CPU_irq_rawstat 0xe004 /* width RMuint32 */
+#define CPU_irq_enableset 0xe008 /* width RMuint32 */
+#define CPU_irq_enableclr 0xe00c /* width RMuint32 */
+#define CPU_irq_softset 0xe010 /* width RMuint32 */
+#define CPU_irq_softclr 0xe014 /* width RMuint32 */
+#define CPU_fiq_status 0xe100 /* width RMuint32 */
+#define CPU_fiq_rawstat 0xe104 /* width RMuint32 */
+#define CPU_fiq_enableset 0xe108 /* width RMuint32 */
+#define CPU_fiq_enableclr 0xe10c /* width RMuint32 */
+#define CPU_fiq_softset 0xe110 /* width RMuint32 */
+#define CPU_fiq_softclr 0xe114 /* width RMuint32 */
+#define CPU_edge_status 0xe200 /* width RMuint32 */
+#define CPU_edge_rawstat 0xe204 /* width RMuint32 */
+#define CPU_edge_config_rise 0xe208 /* width RMuint32 */
+#define CPU_edge_config_fall 0xe20c /* width RMuint32 */
+#define CPU_SOFT_INT 0x00000001 /* width RMuint32 */
+#define CPU_UART0_INT 0x00000002 /* width RMuint32 */
+#define CPU_UART1_INT 0x00000004 /* width RMuint32 */
+#define CPU_TIMER0_INT 0x00000020 /* width RMuint32 */
+#define CPU_TIMER1_INT 0x00000040 /* width RMuint32 */
+#define CPU_HOST_MBUS_W0_INT 0x00000200 /* width RMuint32 */
+#define CPU_HOST_MBUS_W1_INT 0x00000400 /* width RMuint32 */
+#define CPU_HOST_MBUS_R0_INT 0x00000800 /* width RMuint32 */
+#define CPU_HOST_MBUS_R1_INT 0x00001000 /* width RMuint32 */
+#define CPU_PCI_INTA 0x00002000 /* width RMuint32 */
+#define CPU_PCI_INTB 0x00004000 /* width RMuint32 */
+#define CPU_PCI_INTC 0x00008000 /* width RMuint32 */
+#define CPU_PCI_INTD 0x00010000 /* width RMuint32 */
+#define CPU_PCI_FAULT_INT 0x00100000 /* width RMuint32 */
+#define CPU_SFLA_INT 0x00000010 /* width RMuint32 */
+#define CPU_DVD_INT 0x00000080 /* width RMuint32 */
+#define CPU_ETH_INT 0x00000100 /* width RMuint32 */
+#define CPU_DMAIDE_INT 0x00020000 /* width RMuint32 */
+#define CPU_IDE_INT 0x00040000 /* width RMuint32 */
+#define CPU_FRONTPANEL_INT 0x00080000 /* width RMuint32 */
+#define CPU_INFRARED_INT 0x00200000 /* width RMuint32 */
+#define CPU_I2C_INT 0x00400000 /* width RMuint32 */
+#define CPU_GFX_ACCEL_INT 0x00800000 /* width RMuint32 */
+#define CPU_VSYNC0_INT 0x01000000 /* width RMuint32 */
+#define CPU_VSYNC1_INT 0x02000000 /* width RMuint32 */
+#define CPU_VSYNC2_INT 0x04000000 /* width RMuint32 */
+#define CPU_VSYNC3_INT 0x08000000 /* width RMuint32 */
+#define CPU_VSYNC4_INT 0x10000000 /* width RMuint32 */
+#define CPU_VSYNC4BKEND_INT 0x20000000 /* width RMuint32 */
+#define CPU_VSYNC5_INT 0x40000000 /* width RMuint32 */
+#define CPU_VSYNC5BKEND_INT 0x80000000 /* width RMuint32 */
+#define CPU_SMARTCARD_HI_INT 0x00000001 /* width RMuint32 */
+#define CPU_HDMI_HI_INT 0x00000002 /* width RMuint32 */
+#define CPU_HDMI_I2C_HI_INT 0x00000004 /* width RMuint32 */
+#define CPU_VBUS_W0_HI_INT 0x00000008 /* width RMuint32 */
+#define CPU_VBUS_W3_HI_INT 0x00000010 /* width RMuint32 */
+#define CPU_ETH_PHY_HI_INT 0x00000020 /* width RMuint32 */
+#define CPU_ETH_MAC_HI_INT 0x00000040 /* width RMuint32 */
+#define CPU_USB_OHCI_MAC_HI_INT 0x00000080 /* width RMuint32 */
+#define CPU_USB_EHCI_MAC_HI_INT 0x00000100 /* width RMuint32 */
+#define LOG2_CPU_SOFT_INT 0 /* width RMuint32 */
+#define LOG2_CPU_UART0_INT 1 /* width RMuint32 */
+#define LOG2_CPU_UART1_INT 2 /* width RMuint32 */
+#define LOG2_CPU_TIMER0_INT 5 /* width RMuint32 */
+#define LOG2_CPU_TIMER1_INT 6 /* width RMuint32 */
+#define LOG2_CPU_DVD_INT 7 /* width RMuint32 */
+#define LOG2_CPU_RTC_INT 8 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W0_INT 9 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_W1_INT 10 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R0_INT 11 /* width RMuint32 */
+#define LOG2_CPU_HOST_MBUS_R1_INT 12 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTA 13 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTB 14 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTC 15 /* width RMuint32 */
+#define LOG2_CPU_PCI_INTD 16 /* width RMuint32 */
+#define LOG2_CPU_DMAIDE_INT 17 /* width RMuint32 */
+#define LOG2_CPU_IDE_INT 18 /* width RMuint32 */
+#define LOG2_CPU_FRONTPANEL_INT 19 /* width RMuint32 */
+#define LOG2_CPU_PCI_FAULT_INT 20 /* width RMuint32 */
+#define LOG2_CPU_INFRARED_INT 21 /* width RMuint32 */
+#define LOG2_CPU_I2C_INT 22 /* width RMuint32 */
+#define LOG2_CPU_GFX_ACCEL_INT 23 /* width RMuint32 */
+#define LOG2_CPU_VSYNC0_INT 24 /* width RMuint32 */
+#define LOG2_CPU_VSYNC1_INT 25 /* width RMuint32 */
+#define LOG2_CPU_VSYNC2_INT 26 /* width RMuint32 */
+#define LOG2_CPU_VSYNC3_INT 27 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4_INT 28 /* width RMuint32 */
+#define LOG2_CPU_VSYNC4BKEND_INT 29 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5_INT 30 /* width RMuint32 */
+#define LOG2_CPU_VSYNC5BKEND_INT 31 /* width RMuint32 */
+#define LOG2_CPU_SMARTCARD_INT 32 /* width RMuint32 */
+#define LOG2_CPU_HDMI_INT 33 /* width RMuint32 */
+#define LOG2_CPU_HDMI_I2C_INT 34 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W0_INT 35 /* width RMuint32 */
+#define LOG2_CPU_VBUS_W3_INT 36 /* width RMuint32 */
+#define LOG2_CPU_ETH_PHY_INT 37 /* width RMuint32 */
+#define LOG2_CPU_ETH_MAC_INT 38 /* width RMuint32 */
+#define LOG2_CPU_USB_OHCI_INT 39 /* width RMuint32 */
+#define LOG2_CPU_USB_EHCI_INT 40 /* width RMuint32 */
+#define CPU_edge_status_hi 0xe220 /* width RMuint32 */
+#define CPU_edge_rawstat_hi 0xe224 /* width RMuint32 */
+#define CPU_edge_config_rise_hi 0xe228 /* width RMuint32 */
+#define CPU_edge_config_fall_hi 0xe22c /* width RMuint32 */
+#define CPU_irq_status_hi 0xe018 /* width RMuint32 */
+#define CPU_irq_rawstat_hi 0xe01c /* width RMuint32 */
+#define CPU_irq_enableset_hi 0xe020 /* width RMuint32 */
+#define CPU_irq_enableclr_hi 0xe024 /* width RMuint32 */
+#define CPU_fiq_status_hi 0xe118 /* width RMuint32 */
+#define CPU_fiq_rawstat_hi 0xe11c /* width RMuint32 */
+#define CPU_fiq_enableset_hi 0xe120 /* width RMuint32 */
+#define CPU_fiq_enableclr_hi 0xe124 /* width RMuint32 */
+#define CPU_iiq_status 0xe300 /* width RMuint32 */
+#define CPU_iiq_rawstat 0xe304 /* width RMuint32 */
+#define CPU_iiq_enableset 0xe308 /* width RMuint32 */
+#define CPU_iiq_enableclr 0xe30c /* width RMuint32 */
+#define CPU_iiq_softset 0xe310 /* width RMuint32 */
+#define CPU_iiq_softclr 0xe314 /* width RMuint32 */
+#define CPU_iiq_status_hi 0xe318 /* width RMuint32 */
+#define CPU_iiq_rawstat_hi 0xe31c /* width RMuint32 */
+#define CPU_iiq_enableset_hi 0xe320 /* width RMuint32 */
+#define CPU_iiq_enableclr_hi 0xe324 /* width RMuint32 */
+#define CPU_UART_GPIOMODE 0x38 /* width RMuint32 */
+#define CPU_UART_GPIODIR 0x30 /* width RMuint32 */
+#define CPU_UART_GPIODATA 0x34 /* width RMuint32 */
+#define CPU_edge_config_rise_set 0xe210 /* width RMuint32 */
+#define CPU_edge_config_rise_clr 0xe214 /* width RMuint32 */
+#define CPU_edge_config_fall_set 0xe218 /* width RMuint32 */
+#define CPU_edge_config_fall_clr 0xe21c /* width RMuint32 */
+#define CPU_edge_config_rise_set_hi 0xe230 /* width RMuint32 */
+#define CPU_edge_config_rise_clr_hi 0xe234 /* width RMuint32 */
+#define CPU_edge_config_fall_set_hi 0xe238 /* width RMuint32 */
+#define CPU_edge_config_fall_clr_hi 0xe23c /* width RMuint32 */
+#define CPU_remap 0xf000 /* width RMuint32 */
+#define CPU_remap1 0xf004 /* width RMuint32 */
+#define CPU_remap2 0xf008 /* width RMuint32 */
+#define CPU_remap3 0xf00c /* width RMuint32 */
+#define CPU_remap4 0xf010 /* width RMuint32 */
+#define CPU_remap_address 0x1fc00000 /* width RMuint32 */
+#define CPU_remap1_address 0 /* width RMuint32 */
+#define CPU_remap2_address 0x04000000 /* width RMuint32 */
+#define CPU_remap3_address 0x08000000 /* width RMuint32 */
+#define CPU_remap4_address 0x0c000000 /* width RMuint32 */
+#define REG_BASE_xpu_block 0xe0000 /* width RMuint32 */
+#define REG_BASE_irq_handler_block 0xe0000 /* width RMuint32 */
+#define G2L_BIST_BUSY 0xffe0 /* width RMuint32 */
+#define G2L_BIST_PASS 0xffe4 /* width RMuint32 */
+#define G2L_BIST_MASK 0xffe8 /* width RMuint32 */
+#define G2L_RESET_CONTROL 0xfffc /* width RMuint32 */
+#define CPU_UART0_base 0xc100 /* width RMuint32 */
+#define CPU_UART1_base 0xc200 /* width RMuint32 */
+#define CPU_UART_RBR 0x00 /* width RMuint32 */
+#define CPU_UART_THR 0x04 /* width RMuint32 */
+#define CPU_UART_IER 0x08 /* width RMuint32 */
+#define CPU_UART_IIR 0x0c /* width RMuint32 */
+#define CPU_UART_FCR 0x10 /* width RMuint32 */
+#define CPU_UART_LCR 0x14 /* width RMuint32 */
+#define CPU_UART_MCR 0x18 /* width RMuint32 */
+#define CPU_UART_LSR 0x1c /* width RMuint32 */
+#define CPU_UART_MSR 0x20 /* width RMuint32 */
+#define CPU_UART_SCR 0x24 /* width RMuint32 */
+#define CPU_UART_CLKDIV 0x28 /* width RMuint32 */
+#define CPU_UART_CLKSEL 0x2c /* width RMuint32 */
+/* CPUBlock registers done */
+
+/* DisplayBlock registers */
+#define REG_BASE_display_block 0x00070000 /* width RMuint32 */
+#define VO_run 0x0000 /* width RMuint32 */
+#define VO_reset_datapath 0x0004 /* width RMuint32 */
+#define VO_reset_timing 0x0008 /* width RMuint32 */
+#define VO_reset_config 0x000c /* width RMuint32 */
+#define VO_reset_mode_0 0x0014 /* width RMuint32 */
+#define VO_reset_mode_1 0x0018 /* width RMuint32 */
+#define VIF_w0 0x4000 /* width RMuint32 */
+#define VIF_w1 0x4100 /* width RMuint32 */
+#define VIF_w2 0x4200 /* width RMuint32 */
+#define VIF_r0 0x4300 /* width RMuint32 */
+#define VIF_r1 0x4400 /* width RMuint32 */
+#define VIF_r2 0x4500 /* width RMuint32 */
+#define VIF_r3 0x4600 /* width RMuint32 */
+#define VIF_r4 0x4700 /* width RMuint32 */
+#define VIF_r5 0x4800 /* width RMuint32 */
+#define VIF_r6 0x4900 /* width RMuint32 */
+#define VIF_r7 0x4A00 /* width RMuint32 */
+#define VIF_r8 0x4B00 /* width RMuint32 */
+#define VIF_r9 0x4C00 /* width RMuint32 */
+#define VIF_r10 0x4D00 /* width RMuint32 */
+#define VIF_r11 0x4E00 /* width RMuint32 */
+#define VIF_offs 0x0100 /* width RMuint32 */
+#define VIF_add 0x0000 /* width RMuint32 */
+#define VIF_cnt 0x0004 /* width RMuint32 */
+#define VIF_skip 0x0008 /* width RMuint32 */
+#define VIF_cmd 0x000c /* width RMuint32 */
+#define VIF_addB 0x0010 /* width RMuint32 */
+#define VIF_cntB 0x0014 /* width RMuint32 */
+#define VIF_skipB 0x0018 /* width RMuint32 */
+#define VBUS_IDLE 0x0 /* width RMuint32 */
+#define VBUS_LINEAR 0x1 /* width RMuint32 */
+#define VBUS_DOUBLE 0x2 /* width RMuint32 */
+#define VBUS_RECTANGLE 0x3 /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD 0x4 /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE 0x5 /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN 0x6 /* width RMuint32 */
+#define VBUS_VOID 0x8 /* width RMuint32 */
+#define VBUS_LINEAR_VOID 0x9 /* width RMuint32 */
+#define VBUS_DOUBLE_VOID 0xa /* width RMuint32 */
+#define VBUS_RECTANGLE_VOID 0xb /* width RMuint32 */
+#define VBUS_DOUBLE_FIELD_VOID 0xc /* width RMuint32 */
+#define VBUS_DOUBLE_RECTANGLE_VOID 0xd /* width RMuint32 */
+#define VBUS_8BYTE_COLUMN_VOID 0xe /* width RMuint32 */
+/* DisplayBlock registers done */
+
+/* DispOSDScaler registers */
+#define VO_osd_reset_bit 0x03 /* width RMuint32 */
+#define VO_osd_format_hds 0x0300 /* width RMuint32 */
+#define VO_osd_output_size 0x0304 /* width RMuint32 */
+#define VO_osd_scale_factor 0x0308 /* width RMuint32 */
+#define VO_osd_scale_phase_flicker 0x030c /* width RMuint32 */
+#define VO_osd_alpha_routing 0x0310 /* width RMuint32 */
+#define VO_osd_key_color 0x0314 /* width RMuint32 */
+#define VO_osd_lut 0x9000 /* width RMuint32 */
+#define VO_osd_lut0 0x9000 /* width RMuint32 */
+/* DispOSDScaler registers done */
+
+/* DispHardwareCursor registers */
+#define VO_cursor_reset_bit 0x01 /* width RMuint32 */
+#define VO_cursor_size_ctrl 0x0100 /* width RMuint32 */
+#define VO_cursor_lut 0x0140 /* width RMuint32 */
+#define VO_cursor_lut0 0x0140 /* width RMuint32 */
+#define VO_cursor_lut1 0x0144 /* width RMuint32 */
+#define VO_cursor_lut2 0x0148 /* width RMuint32 */
+#define VO_cursor_lut3 0x014c /* width RMuint32 */
+#define VO_cursor_lut4 0x0150 /* width RMuint32 */
+#define VO_cursor_lut5 0x0154 /* width RMuint32 */
+#define VO_cursor_lut6 0x0158 /* width RMuint32 */
+#define VO_cursor_lut7 0x015c /* width RMuint32 */
+#define VO_cursor_lut8 0x0160 /* width RMuint32 */
+#define VO_cursor_lut9 0x0164 /* width RMuint32 */
+#define VO_cursor_lut10 0x0168 /* width RMuint32 */
+#define VO_cursor_lut11 0x016c /* width RMuint32 */
+#define VO_cursor_lut12 0x0170 /* width RMuint32 */
+#define VO_cursor_lut13 0x0174 /* width RMuint32 */
+#define VO_cursor_lut14 0x0178 /* width RMuint32 */
+#define VO_cursor_lut15 0x017c /* width RMuint32 */
+#define VO_cursor_pix 0x8000 /* width RMuint32 */
+#define VO_cursor_pix0 0x8000 /* width RMuint32 */
+/* DispHardwareCursor registers done */
+
+/* DispMainVideoScaler registers */
+#define VO_main_reset_bit 0x04 /* width RMuint32 */
+#define VO_main_format_hds 0x0400 /* width RMuint32 */
+#define VO_main_output_size 0x0404 /* width RMuint32 */
+#define VO_main_scale_factor 0x0408 /* width RMuint32 */
+#define VO_main_scale_phase 0x040c /* width RMuint32 */
+#define VO_main_phase 0x040c /* width RMuint32 */
+#define VO_main_alpha_deint_routing 0x0410 /* width RMuint32 */
+#define VO_main_deint2 0x0414 /* width RMuint32 */
+#define VO_main_bcs 0x0418 /* width RMuint32 */
+#define VO_main_pulldown 0x041c /* width RMuint32 */
+#define VO_main_strip_filter 0x0420 /* width RMuint32 */
+#define VO_main_nonlinear_0 0x0424 /* width RMuint32 */
+#define VO_main_nonlinear_1 0x0428 /* width RMuint32 */
+/* DispMainVideoScaler registers done */
+
+/* DispSubPictureScaler registers */
+#define VO_subp_reset_bit 0x02 /* width RMuint32 */
+#define VO_subp_format_hds 0x0200 /* width RMuint32 */
+#define VO_subp_output_size 0x0204 /* width RMuint32 */
+#define VO_subp_scale_factor 0x0208 /* width RMuint32 */
+#define VO_subp_scale_phase_routing 0x020c /* width RMuint32 */
+#define VO_sp_lut 0x0240 /* width RMuint32 */
+#define VO_sp_lut0 0x0240 /* width RMuint32 */
+/* DispSubPictureScaler registers done */
+
+/* DispVCRMultiScaler registers */
+#define VO_VCR_reset_bit 0x05 /* width RMuint32 */
+#define VO_VCR_format_hds 0x0500 /* width RMuint32 */
+#define VO_VCR_output_size 0x0504 /* width RMuint32 */
+#define VO_VCR_scale_factor 0x0508 /* width RMuint32 */
+#define VO_VCR_scale_phase 0x050c /* width RMuint32 */
+#define VO_VCR_phase 0x050c /* width RMuint32 */
+#define VO_VCR_alpha_routing 0x0510 /* width RMuint32 */
+#define VO_VCR_key_color 0x0514 /* width RMuint32 */
+#define VO_VCR_bcs 0x0518 /* width RMuint32 */
+#define VO_VCR_strip_edge 0x051C /* width RMuint32 */
+#define VO_VCR_nonlinear_0 0x0520 /* width RMuint32 */
+#define VO_VCR_nonlinear_1 0x0524 /* width RMuint32 */
+#define VO_VCR_tiling 0x0528 /* width RMuint32 */
+#define VO_VCR_lut 0xa000 /* width RMuint32 */
+#define VO_VCR_lut0 0xa000 /* width RMuint32 */
+/* DispVCRMultiScaler registers done */
+
+/* DispCRTMultiScaler registers */
+#define VO_CRT_reset_bit 0x06 /* width RMuint32 */
+#define VO_CRT_format_hds 0x0600 /* width RMuint32 */
+#define VO_CRT_output_size 0x0604 /* width RMuint32 */
+#define VO_CRT_scale_factor 0x0608 /* width RMuint32 */
+#define VO_CRT_scale_phase 0x060c /* width RMuint32 */
+#define VO_CRT_phase 0x060c /* width RMuint32 */
+#define VO_CRT_alpha_routing 0x0610 /* width RMuint32 */
+#define VO_CRT_key_color 0x0614 /* width RMuint32 */
+#define VO_CRT_bcs 0x0618 /* width RMuint32 */
+#define VO_CRT_strip_edge 0x061C /* width RMuint32 */
+#define VO_CRT_nonlinear_0 0x0620 /* width RMuint32 */
+#define VO_CRT_nonlinear_1 0x0624 /* width RMuint32 */
+#define VO_CRT_tiling 0x0628 /* width RMuint32 */
+#define VO_CRT_lut 0xb000 /* width RMuint32 */
+#define VO_CRT_lut0 0xb000 /* width RMuint32 */
+/* DispCRTMultiScaler registers done */
+
+/* DispGFXMultiScaler registers */
+#define VO_GFX_reset_bit 0x07 /* width RMuint32 */
+#define VO_GFX_format_hds 0x0700 /* width RMuint32 */
+#define VO_GFX_output_size 0x0704 /* width RMuint32 */
+#define VO_GFX_scale_factor 0x0708 /* width RMuint32 */
+#define VO_GFX_scale_phase 0x070c /* width RMuint32 */
+#define VO_GFX_phase 0x070c /* width RMuint32 */
+#define VO_GFX_alpha_routing 0x0710 /* width RMuint32 */
+#define VO_GFX_key_color 0x0714 /* width RMuint32 */
+#define VO_GFX_bcs 0x0718 /* width RMuint32 */
+#define VO_GFX_strip_edge 0x071C /* width RMuint32 */
+#define VO_GFX_nonlinear_0 0x0720 /* width RMuint32 */
+#define VO_GFX_nonlinear_1 0x0724 /* width RMuint32 */
+#define VO_GFX_tiling 0x0728 /* width RMuint32 */
+#define VO_GFX_lut 0xc000 /* width RMuint32 */
+#define VO_GFX_lut0 0xc000 /* width RMuint32 */
+/* DispGFXMultiScaler registers done */
+
+/* DispMainMixer registers */
+#define VO_mix_reset_bit 0x08 /* width RMuint32 */
+#define VO_mix_gfx_pos 0x0800 /* width RMuint32 */
+#define VO_mix_crt_pos 0x0804 /* width RMuint32 */
+#define VO_mix_vcr_pos 0x0808 /* width RMuint32 */
+#define VO_mix_sp_pos 0x080C /* width RMuint32 */
+#define VO_mix_mv_pos 0x0810 /* width RMuint32 */
+#define VO_mix_osd_pos 0x0814 /* width RMuint32 */
+#define VO_mix_gin_pos 0x0818 /* width RMuint32 */
+#define VO_mix_cur_pos 0x081C /* width RMuint32 */
+#define VO_mix_index 0x0820 /* width RMuint32 */
+#define VO_mix_frame_size 0x0824 /* width RMuint32 */
+#define VO_mix_background 0x0828 /* width RMuint32 */
+/* DispMainMixer registers done */
+
+/* DispVCRMixer registers */
+#define VO_vcrmix_reset_bit 0x09 /* width RMuint32 */
+#define VO_vcrmix_gfx_pos 0x0900 /* width RMuint32 */
+#define VO_vcrmix_crt_pos 0x0904 /* width RMuint32 */
+#define VO_vcrmix_sp_pos 0x0908 /* width RMuint32 */
+#define VO_vcrmix_vcr_pos 0x090C /* width RMuint32 */
+#define VO_vcrmix_index 0x0910 /* width RMuint32 */
+#define VO_vcrmix_frame_size 0x0914 /* width RMuint32 */
+#define VO_vcrmix_background 0x0918 /* width RMuint32 */
+/* DispVCRMixer registers done */
+
+/* DispColorBars registers */
+#define VO_color_bars_reset_bit 0x0b /* width RMuint32 */
+#define VO_color_bars_ctrl 0x0d00 /* width RMuint32 */
+#define VO_color_bars_size 0x0d04 /* width RMuint32 */
+/* DispColorBars registers done */
+
+/* DispRouting registers */
+#define VO_routing_reset_bit 0x16 /* width RMuint32 */
+#define VO_routing_ctrl 0x1208 /* width RMuint32 */
+/* DispRouting registers done */
+
+/* DispVideoInput registers */
+#define VO_vid_in_reset_bit 0x10 /* width RMuint32 */
+#define VO_vid_in_format 0x0b00 /* width RMuint32 */
+#define VO_vid_in_data_size 0x0b04 /* width RMuint32 */
+#define VO_vid_in_data_Xoffset 0x0b08 /* width RMuint32 */
+#define VO_vid_in_data_Yoffset 0x0b0c /* width RMuint32 */
+#define VO_vid_in_hz_sync 0x0b10 /* width RMuint32 */
+#define VO_vid_in_vt_sync 0x0b14 /* width RMuint32 */
+#define VO_vid_in_sync_coord 0x0b18 /* width RMuint32 */
+#define VO_vid_in_top_vbi 0x0b1c /* width RMuint32 */
+#define VO_vid_in_bot_vbi 0x0b20 /* width RMuint32 */
+#define VO_vid_in_counters 0x0b24 /* width RMuint32 */
+#define VO_vid_in_vbi_size 0x0b28 /* width RMuint32 */
+#define VO_vid_in_vbi_vsm 0x0b2c /* width RMuint32 */
+#define VO_vid_in_vbi_Voffset 0x0b30 /* width RMuint32 */
+#define VO_vid_in_format2 0x0b34 /* width RMuint32 */
+#define VO_vid_in_counters2 0x0b38 /* width RMuint32 */
+/* DispVideoInput registers done */
+
+/* DispGraphicInput registers */
+#define VO_graph_in_reset_bit 0x11 /* width RMuint32 */
+#define VO_graph_in_format 0x0c00 /* width RMuint32 */
+#define VO_graph_in_alpha_routing 0x0c04 /* width RMuint32 */
+#define VO_graph_in_key_color 0x0c08 /* width RMuint32 */
+#define VO_graph_in_data_size 0x0c0c /* width RMuint32 */
+#define VO_graph_in_data_Xoffset 0x0c10 /* width RMuint32 */
+#define VO_graph_in_data_Yoffset 0x0c14 /* width RMuint32 */
+#define VO_graph_in_hz_sync 0x0c18 /* width RMuint32 */
+#define VO_graph_in_vt_sync 0x0c1c /* width RMuint32 */
+#define VO_graph_in_sync_coord 0x0c20 /* width RMuint32 */
+#define VO_graph_in_sync_offset 0x0c24 /* width RMuint32 */
+#define VO_graph_in_top_vbi 0x0c28 /* width RMuint32 */
+#define VO_graph_in_bot_vbi 0x0c2c /* width RMuint32 */
+#define VO_graph_in_counters 0x0c30 /* width RMuint32 */
+#define VO_graph_in_format2 0x0c34 /* width RMuint32 */
+#define VO_graph_in_counters2 0x0c38 /* width RMuint32 */
+#define VO_graph_in_vbi_size 0x0c3c /* width RMuint32 */
+#define VO_graph_in_vbi_vsm 0x0c40 /* width RMuint32 */
+#define VO_graph_in_vbi_Voffset 0x0c44 /* width RMuint32 */
+/* DispGraphicInput registers done */
+
+/* DispDigitalOut registers */
+#define VO_digit_out_reset_bit 0x12 /* width RMuint32 */
+#define VO_digit_out_conv0 0x0e00 /* width RMuint32 */
+#define VO_digit_out_conv1 0x0e04 /* width RMuint32 */
+#define VO_digit_out_conv2 0x0e08 /* width RMuint32 */
+#define VO_digit_out_conv3 0x0e0c /* width RMuint32 */
+#define VO_digit_out_conv4 0x0e10 /* width RMuint32 */
+#define VO_digit_out_conv5 0x0e14 /* width RMuint32 */
+#define VO_digit_out_format 0x0e20 /* width RMuint32 */
+#define VO_digit_out_Xoffset 0x0e24 /* width RMuint32 */
+#define VO_digit_out_Yoffset 0x0e28 /* width RMuint32 */
+#define VO_digit_out_hz_sync 0x0e2c /* width RMuint32 */
+#define VO_digit_out_vt_sync 0x0e30 /* width RMuint32 */
+#define VO_digit_out_vsync_coord 0x0e34 /* width RMuint32 */
+#define VO_digit_out_pads_config 0x0020 /* width RMuint32 */
+#define VO_digit_out_gamma_lut0 0xf000 /* width RMuint32 */
+#define VO_digit_out_temp_lut0 0xf400 /* width RMuint32 */
+/* DispDigitalOut registers done */
+
+/* DispMainAnalogOut registers */
+#define VO_main_analog_reset_bit 0x13 /* width RMuint32 */
+#define VO_main_analog_conv0 0x0f00 /* width RMuint32 */
+#define VO_main_analog_conv1 0x0f04 /* width RMuint32 */
+#define VO_main_analog_conv2 0x0f08 /* width RMuint32 */
+#define VO_main_analog_conv3 0x0f0c /* width RMuint32 */
+#define VO_main_analog_conv4 0x0f10 /* width RMuint32 */
+#define VO_main_analog_conv5 0x0f14 /* width RMuint32 */
+#define VO_main_analog_xoffset_field 0x0f18 /* width RMuint32 */
+#define VO_main_analog_yoffset 0x0f1c /* width RMuint32 */
+#define VO_main_analog_cvbs_conv0 0x0f20 /* width RMuint32 */
+#define VO_main_analog_cvbs_conv1 0x0f24 /* width RMuint32 */
+#define VO_main_analog_cvbs_conv2 0x0f28 /* width RMuint32 */
+#define VO_main_analog_cvbs_conv3 0x0f2c /* width RMuint32 */
+#define VO_main_analog_cvbs_conv4 0x0f30 /* width RMuint32 */
+#define VO_main_analog_cvbs_conv5 0x0f34 /* width RMuint32 */
+#define VO_main_analog_TV_config 0x0f40 /* width RMuint32 */
+#define VO_main_analog_TV_size 0x0f44 /* width RMuint32 */
+#define VO_main_analog_TV_hsync 0x0f48 /* width RMuint32 */
+#define VO_main_analog_TV_vsync_O_0 0x0f4c /* width RMuint32 */
+#define VO_main_analog_TV_vsync_O_1 0x0f50 /* width RMuint32 */
+#define VO_main_analog_TV_vsync_E_0 0x0f54 /* width RMuint32 */
+#define VO_main_analog_TV_vsync_E_1 0x0f58 /* width RMuint32 */
+#define VO_main_analog_TV_HD_hsync_info 0x0f5c /* width RMuint32 */
+#define VO_main_analog_TV_HD_vsync 0x0f60 /* width RMuint32 */
+#define VO_main_analog_TV_CGMS 0x0f64 /* width RMuint32 */
+#define VO_main_analog_TV_CC_AGC 0x0f68 /* width RMuint32 */
+#define VO_main_analog_TV_test_config 0x0f6c /* width RMuint32 */
+#define VO_main_analog_TV_teletext_config 0x0f70 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_0_22 0x0f80 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_1_2_3_4 0x0f84 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_5_6_7_8 0x0f88 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_9_10_11 0x0f8c /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_12_13_14 0x0f90 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_15_16_17_18 0x0f94 /* width RMuint32 */
+#define VO_main_analog_TV_MV_N_19_20_21 0x0f98 /* width RMuint32 */
+/* DispMainAnalogOut registers done */
+
+/* DispComponentOut registers */
+#define VO_component_out_reset_bit 0x14 /* width RMuint32 */
+#define VO_component_out_conv0 0x1000 /* width RMuint32 */
+#define VO_component_out_conv1 0x1004 /* width RMuint32 */
+#define VO_component_out_conv2 0x1008 /* width RMuint32 */
+#define VO_component_out_conv3 0x100c /* width RMuint32 */
+#define VO_component_out_conv4 0x1010 /* width RMuint32 */
+#define VO_component_out_conv5 0x1014 /* width RMuint32 */
+#define VO_component_out_xoffset_field 0x1018 /* width RMuint32 */
+#define VO_component_out_yoffset 0x101c /* width RMuint32 */
+#define VO_component_out_TV_config 0x1040 /* width RMuint32 */
+#define VO_component_out_TV_size 0x1044 /* width RMuint32 */
+#define VO_component_out_TV_hsync 0x1048 /* width RMuint32 */
+#define VO_component_out_TV_vsync_O_0 0x104c /* width RMuint32 */
+#define VO_component_out_TV_vsync_O_1 0x1050 /* width RMuint32 */
+#define VO_component_out_TV_vsync_E_0 0x1054 /* width RMuint32 */
+#define VO_component_out_TV_vsync_E_1 0x1058 /* width RMuint32 */
+#define VO_component_out_TV_HD_hsync_info 0x105c /* width RMuint32 */
+#define VO_component_out_TV_HD_vsync 0x1060 /* width RMuint32 */
+#define VO_component_out_TV_CGMS 0x1064 /* width RMuint32 */
+#define VO_component_out_TV_CC_AGC 0x1068 /* width RMuint32 */
+#define VO_component_out_TV_test_config 0x106c /* width RMuint32 */
+#define VO_component_out_TV_MV_N_0_22 0x1080 /* width RMuint32 */
+#define VO_component_out_TV_MV_N_1_2_3_4 0x1084 /* width RMuint32 */
+#define VO_component_out_TV_MV_N_5_6_7_8 0x1088 /* width RMuint32 */
+#define VO_component_out_TV_MV_N_9_10_11 0x108c /* width RMuint32 */
+#define VO_component_out_TV_MV_N_12_13_14 0x1090 /* width RMuint32 */
+#define VO_component_out_TV_MV_N_15_16_17_18 0x1094 /* width RMuint32 */
+#define VO_component_out_TV_MV_N_19_20_21 0x1098 /* width RMuint32 */
+/* DispComponentOut registers done */
+
+/* DispCompositeOut registers */
+#define VO_composite_out_reset_bit 0x15 /* width RMuint32 */
+#define VO_composite_out_bcs 0x1100 /* width RMuint32 */
+#define VO_composite_out_Xoffset 0x1104 /* width RMuint32 */
+#define VO_composite_out_Yoffset 0x1108 /* width RMuint32 */
+#define VO_composite_out_TV_config 0x1140 /* width RMuint32 */
+#define VO_composite_out_TV_size 0x1144 /* width RMuint32 */
+#define VO_composite_out_TV_hsync 0x1148 /* width RMuint32 */
+#define VO_composite_out_TV_vsync_O_0 0x114c /* width RMuint32 */
+#define VO_composite_out_TV_vsync_O_1 0x1150 /* width RMuint32 */
+#define VO_composite_out_TV_vsync_E_0 0x1154 /* width RMuint32 */
+#define VO_composite_out_TV_vsync_E_1 0x1158 /* width RMuint32 */
+#define VO_composite_out_TV_CGMS 0x1164 /* width RMuint32 */
+#define VO_composite_out_TV_CC_AGC 0x1168 /* width RMuint32 */
+#define VO_composite_out_TV_test_config 0x116c /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_0_22 0x1180 /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_1_2_3_4 0x1184 /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_5_6_7_8 0x1188 /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_9_10_11 0x118c /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_12_13_14 0x1190 /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_15_16_17_18 0x1194 /* width RMuint32 */
+#define VO_composite_out_TV_MV_N_19_20_21 0x1198 /* width RMuint32 */
+/* DispCompositeOut registers done */
+
+/* DemuxEngine registers */
+#define REG_BASE_demux_engine 0x000A0000 /* width RMuint32 */
+#define MEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define PMEM_BASE_demux_engine 0x00140000 /* width RMuint32 */
+#define DMEM_BASE_demux_engine 0x00150000 /* width RMuint32 */
+#define demux_mutex0 0x1e90 /* width RMuint32 */
+#define demux_mutex1 0x1e91 /* width RMuint32 */
+#define demux_mutex2 0x1e92 /* width RMuint32 */
+#define demux_mutex3 0x1e93 /* width RMuint32 */
+#define demux_mutex4 0x1e94 /* width RMuint32 */
+#define demux_mutex5 0x1e95 /* width RMuint32 */
+#define demux_mutex6 0x1e96 /* width RMuint32 */
+#define demux_mutex7 0x1e97 /* width RMuint32 */
+#define demux_MBUSIF_w0_add 0x1ec0 /* width RMuint32 */
+#define demux_MBUSIF_w0_cnt 0x1ec1 /* width RMuint32 */
+#define demux_MBUSIF_w0_skip 0x1ec2 /* width RMuint32 */
+#define demux_MBUSIF_w0_cmd 0x1ec3 /* width RMuint32 */
+#define demux_MBUSIF_r0_add 0x1ed0 /* width RMuint32 */
+#define demux_MBUSIF_r0_cnt 0x1ed1 /* width RMuint32 */
+#define demux_MBUSIF_r0_skip 0x1ed2 /* width RMuint32 */
+#define demux_MBUSIF_r0_cmd 0x1ed3 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_WADD 0x1ea0 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_RADD 0x1ea1 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_BYTE 0x1ea2 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_WORD 0x1ea3 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_DWORD 0x1ea4 /* width RMuint32 */
+#define demux_GBUSIF_MAIN_STATUS 0x1ea5 /* width RMuint32 */
+#define demux_GBUSIF_ISR_WADD 0x1ea8 /* width RMuint32 */
+#define demux_GBUSIF_ISR_RADD 0x1ea9 /* width RMuint32 */
+#define demux_GBUSIF_ISR_BYTE 0x1eaa /* width RMuint32 */
+#define demux_GBUSIF_ISR_WORD 0x1eab /* width RMuint32 */
+#define demux_GBUSIF_ISR_DWORD 0x1eac /* width RMuint32 */
+#define demux_GBUSIF_ISR_STATUS 0x1ead /* width RMuint32 */
+#define demux_MISC_dr_mode 0x1e80 /* width RMuint32 */
+#define demux_MISC_dr_length 0x1e81 /* width RMuint32 */
+#define demux_MISC_dr_address 0x1e82 /* width RMuint32 */
+#define demux_MISC_dw_mode 0x1e84 /* width RMuint32 */
+#define demux_MISC_dw_length 0x1e85 /* width RMuint32 */
+#define demux_MISC_dw_address 0x1e86 /* width RMuint32 */
+#define demux_MISC_reset0 0x1e88 /* width RMuint32 */
+#define demux_MISC_reset1 0x1e89 /* width RMuint32 */
+#define demux_MISC_interrupt 0x1e8A /* width RMuint32 */
+#define demux_MISC_timer_div 0x1e8B /* width RMuint32 */
+#define demux_MISC_timer_count 0x1e8C /* width RMuint32 */
+#define demux_cipher_rc4_key_0 0x1e40 /* width RMuint32 */
+#define demux_cipher_rc4_key_1 0x1e41 /* width RMuint32 */
+#define demux_cipher_rc4_key_2 0x1e42 /* width RMuint32 */
+#define demux_cipher_rc4_key_3 0x1e43 /* width RMuint32 */
+#define demux_cipher_rc4_key_4 0x1e44 /* width RMuint32 */
+#define demux_cipher_rc4_key_5 0x1e45 /* width RMuint32 */
+#define demux_cipher_rc4_key_6 0x1e46 /* width RMuint32 */
+#define demux_cipher_rc4_key_7 0x1e47 /* width RMuint32 */
+#define demux_cipher_rc4_flags 0x1e48 /* width RMuint32 */
+#define demux_cipher_des_key1_1 0x1e50 /* width RMuint32 */
+#define demux_cipher_des_key1_2 0x1e51 /* width RMuint32 */
+#define demux_cipher_des_key2_1 0x1e52 /* width RMuint32 */
+#define demux_cipher_des_key2_2 0x1e53 /* width RMuint32 */
+#define demux_cipher_des_key3_1 0x1e54 /* width RMuint32 */
+#define demux_cipher_des_key3_2 0x1e55 /* width RMuint32 */
+#define demux_cipher_des_IV_1 0x1e56 /* width RMuint32 */
+#define demux_cipher_des_IV_2 0x1e57 /* width RMuint32 */
+#define demux_cipher_des_flags 0x1e58 /* width RMuint32 */
+#define demux_cipher_aes_key_1 0x1e60 /* width RMuint32 */
+#define demux_cipher_aes_key_2 0x1e61 /* width RMuint32 */
+#define demux_cipher_aes_key_3 0x1e62 /* width RMuint32 */
+#define demux_cipher_aes_key_4 0x1e63 /* width RMuint32 */
+#define demux_cipher_aes_key_5 0x1e64 /* width RMuint32 */
+#define demux_cipher_aes_key_6 0x1e65 /* width RMuint32 */
+#define demux_cipher_aes_key_7 0x1e66 /* width RMuint32 */
+#define demux_cipher_aes_key_8 0x1e67 /* width RMuint32 */
+#define demux_cipher_aes_flags 0x1e68 /* width RMuint32 */
+#define demux_cipher_aes_IV_1 0x1e69 /* width RMuint32 */
+#define demux_cipher_aes_IV_2 0x1e6a /* width RMuint32 */
+#define demux_cipher_aes_IV_3 0x1e6b /* width RMuint32 */
+#define demux_cipher_aes_IV_4 0x1e6c /* width RMuint32 */
+#define demux_cipher_aes_IV_5 0x1e6d /* width RMuint32 */
+#define demux_cipher_aes_IV_6 0x1e6e /* width RMuint32 */
+#define demux_cipher_aes_IV_7 0x1e6f /* width RMuint32 */
+#define demux_cipher_aes_IV_8 0x1e70 /* width RMuint32 */
+#define demux_spi_write_ptr0 0x1e08 /* width RMuint32 */
+#define demux_spi_write_ptr1 0x1e09 /* width RMuint32 */
+#define demux_spi_write_ptr2 0x1e0a /* width RMuint32 */
+#define demux_spi_write_ptr3 0x1e0b /* width RMuint32 */
+#define demux_spi_routing 0x1e0c /* width RMuint32 */
+#define demux_spi_clk_phase 0x1e0d /* width RMuint32 */
+#define demux_spi_sync_bytes 0x1e0e /* width RMuint32 */
+#define demux_idma_write_ptr 0x1e18 /* width RMuint32 */
+#define demux_idma_cnt 0x1e19 /* width RMuint32 */
+#define demux_odma_read_ptr 0x1e20 /* width RMuint32 */
+#define demux_odma_cnt 0x1e21 /* width RMuint32 */
+#define demux_odma_sc_stat 0x1e22 /* width RMuint32 */
+#define demux_odma_sc_match 0x1e23 /* width RMuint32 */
+#define demux_sbox_mode 0x1e28 /* width RMuint32 */
+#define demux_MISC_UNRESET_MASK 0xd800 /* width RMuint32 */
+#define demux_MISC_RESET_MASK 0xd8d8 /* width RMuint32 */
+#define demux_SP_init 0x7fe /* width RMuint32 */
+/* DemuxEngine registers done */
+
+/* Demux registers */
+/* Demux registers done */
+
+/* DemuxProgram registers */
+/* DemuxProgram registers done */
+
+/* MpegEngine registers */
+#define REG_BASE_mpeg_engine_0 0x00080000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_0 0x00100000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_0 0x00110000 /* width RMuint32 */
+#define REG_BASE_mpeg_engine_1 0x00090000 /* width RMuint32 */
+#define MEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define PMEM_BASE_mpeg_engine_1 0x00120000 /* width RMuint32 */
+#define DMEM_BASE_mpeg_engine_1 0x00130000 /* width RMuint32 */
+#define mpeg_mutex0 0x0fe0 /* width RMuint32 */
+#define mpeg_mutex1 0x0fe1 /* width RMuint32 */
+#define mpeg_mutex2 0x0fe2 /* width RMuint32 */
+#define mpeg_mutex3 0x0fe3 /* width RMuint32 */
+#define mpeg_mutex4 0x0fe4 /* width RMuint32 */
+#define mpeg_mutex5 0x0fe5 /* width RMuint32 */
+#define mpeg_mutex6 0x0fe6 /* width RMuint32 */
+#define mpeg_mutex7 0x0fe7 /* width RMuint32 */
+#define RBUS_offset 0x4000 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_addlo 0xE80 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_addhi 0xE81 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_xcnt 0xE82 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_ycnt 0xE83 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_skiplo 0xE84 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_skiphi 0xE85 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_cmd 0xE86 /* width RMuint32 */
+#define mpeg_MBUSIF_w0_vbuf_width 0xE87 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_addlo 0xE90 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_addhi 0xE91 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_xcnt 0xE92 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_ycnt 0xE93 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_skiplo 0xE94 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_skiphi 0xE95 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_cmd 0xE96 /* width RMuint32 */
+#define mpeg_MBUSIF_r0_vbuf_width 0xE97 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_addlo 0xEA0 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_addhi 0xEA1 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_xcnt 0xEA2 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_ycnt 0xEA3 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_skiplo 0xEA4 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_skiphi 0xEA5 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_cmd 0xEA6 /* width RMuint32 */
+#define mpeg_MBUSIF_r1_vbuf_width 0xEA7 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_addlo 0xEB0 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_addhi 0xEB1 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_xcnt 0xEB2 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_ycnt 0xEB3 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_skiplo 0xEB4 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_skiphi 0xEB5 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_cmd 0xEB6 /* width RMuint32 */
+#define mpeg_MBUSIF_w1_vbuf_width 0xEB7 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_addlo 0xEC0 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_addhi 0xEC1 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_xcnt 0xEC2 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_ycnt 0xEC3 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_skiplo 0xEC4 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_skiphi 0xEC5 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_cmd 0xEC6 /* width RMuint32 */
+#define mpeg_MBUSIF_r2_vbuf_width 0xEC7 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_WADD_LOW 0xFA0 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_WADD_HIGH 0xFA1 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_RADD_LOW 0xFA2 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_RADD_HIGH 0xFA3 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_BYTE 0xFA4 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_WORD 0xFA5 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_DWORD_LOW 0xFA6 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_DWORD_HIGH 0xFA7 /* width RMuint32 */
+#define mpeg_GBUSIF_MAIN_STATUS 0xFA8 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_WADD_LOW 0xFB0 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_WADD_HIGH 0xFB1 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_RADD_LOW 0xFB2 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_RADD_HIGH 0xFB3 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_BYTE 0xFB4 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_WORD 0xFB5 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_DWORD_LOW 0xFB6 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_DWORD_HIGH 0xFB7 /* width RMuint32 */
+#define mpeg_GBUSIF_ISR_STATUS 0xFB8 /* width RMuint32 */
+#define mpeg_MISC_dr_mode 0xFF0 /* width RMuint32 */
+#define mpeg_MISC_dr_length 0xFF1 /* width RMuint32 */
+#define mpeg_MISC_dr_address 0xFF2 /* width RMuint32 */
+#define mpeg_MISC_sbox_mode 0xFF3 /* width RMuint32 */
+#define mpeg_MISC_dw_mode 0xFF4 /* width RMuint32 */
+#define mpeg_MISC_dw_length 0xFF5 /* width RMuint32 */
+#define mpeg_MISC_dw_address 0xFF6 /* width RMuint32 */
+#define mpeg_MISC_codec_type 0xFF7 /* width RMuint32 */
+#define mpeg_MISC_reset0 0xFF8 /* width RMuint32 */
+#define mpeg_MISC_reset1 0xFF9 /* width RMuint32 */
+#define mpeg_MISC_interrupt 0xFFA /* width RMuint32 */
+#define mpeg_MISC_timer_div 0xFFB /* width RMuint32 */
+#define mpeg_MISC_timer_count 0xFFC /* width RMuint32 */
+#define mpeg_MISC_sbox_read_ctrl 0xFFD /* width RMuint32 */
+#define mpeg_MISC_sbox_write_ctrl 0xFFE /* width RMuint32 */
+#define mpeg_MISC_reserved2 0xFFF /* width RMuint32 */
+#define mpeg_MISC_UNRESET_MASK 0x3500 /* width RMuint32 */
+#define mpeg_MISC_RESET_MASK 0x3535 /* width RMuint32 */
+#define mpeg_SP_init 0x7fe /* width RMuint32 */
+/* MpegEngine registers done */
+
+/* VideoDecoder registers */
+/* VideoDecoder registers done */
+
+/* AudioEngine registers */
+#define REG_BASE_audio_engine_0 0x000c0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_0 0x00180000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_0 0x00190000 /* width RMuint32 */
+#define REG_BASE_audio_engine_1 0x000d0000 /* width RMuint32 */
+#define MEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define PMEM_BASE_audio_engine_1 0x001a0000 /* width RMuint32 */
+#define DMEM_BASE_audio_engine_1 0x001b0000 /* width RMuint32 */
+#define audio_SO_L0_DATA 0x3e00 /* width RMuint32 */
+#define audio_SO_R0_DATA 0x3e01 /* width RMuint32 */
+#define audio_SO_L1_DATA 0x3e02 /* width RMuint32 */
+#define audio_SO_R1_DATA 0x3e03 /* width RMuint32 */
+#define audio_SO_L2_DATA 0x3e04 /* width RMuint32 */
+#define audio_SO_R2_DATA 0x3e05 /* width RMuint32 */
+#define audio_SO_LS_DATA 0x3e06 /* width RMuint32 */
+#define audio_SO_RS_DATA 0x3e07 /* width RMuint32 */
+#define audio_SO_CH_INTR 0x3e08 /* width RMuint32 */
+#define audio_SO_CH_CTRL 0x3e09 /* width RMuint32 */
+#define audio_SO_SPDIF_CH_STAT 0x3e0a /* width RMuint32 */
+#define audio_SO_AUDIO_CLK_DIV 0x3e0e /* width RMuint32 */
+#define audio_SI_L0_DATA 0x3e40 /* width RMuint32 */
+#define audio_SI_R0_DATA 0x3e41 /* width RMuint32 */
+#define audio_SI_STATUS 0x3e42 /* width RMuint32 */
+#define audio_SI_CONF 0x3e43 /* width RMuint32 */
+#define audio_SI_SPDIF_STATUS 0x3e44 /* width RMuint32 */
+#define audio_mutex0 0x3e90 /* width RMuint32 */
+#define audio_mutex1 0x3e91 /* width RMuint32 */
+#define audio_mutex2 0x3e92 /* width RMuint32 */
+#define audio_mutex3 0x3e93 /* width RMuint32 */
+#define audio_mutex4 0x3e94 /* width RMuint32 */
+#define audio_mutex5 0x3e95 /* width RMuint32 */
+#define audio_mutex6 0x3e96 /* width RMuint32 */
+#define audio_mutex7 0x3e97 /* width RMuint32 */
+#define audio_MBUSIF_w0_add 0x3ec0 /* width RMuint32 */
+#define audio_MBUSIF_w0_cnt 0x3ec1 /* width RMuint32 */
+#define audio_MBUSIF_w0_skip 0x3ec2 /* width RMuint32 */
+#define audio_MBUSIF_w0_cmd 0x3ec3 /* width RMuint32 */
+#define audio_MBUSIF_r0_add 0x3ed0 /* width RMuint32 */
+#define audio_MBUSIF_r0_cnt 0x3ed1 /* width RMuint32 */
+#define audio_MBUSIF_r0_skip 0x3ed2 /* width RMuint32 */
+#define audio_MBUSIF_r0_cmd 0x3ed3 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_WADD 0x3ea0 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_RADD 0x3ea1 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_BYTE 0x3ea2 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_WORD 0x3ea3 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_DWORD 0x3ea4 /* width RMuint32 */
+#define audio_GBUSIF_MAIN_STATUS 0x3ea5 /* width RMuint32 */
+#define audio_GBUSIF_ISR_WADD 0x3ea8 /* width RMuint32 */
+#define audio_GBUSIF_ISR_RADD 0x3ea9 /* width RMuint32 */
+#define audio_GBUSIF_ISR_BYTE 0x3eaa /* width RMuint32 */
+#define audio_GBUSIF_ISR_WORD 0x3eab /* width RMuint32 */
+#define audio_GBUSIF_ISR_DWORD 0x3eac /* width RMuint32 */
+#define audio_GBUSIF_ISR_STATUS 0x3ead /* width RMuint32 */
+#define audio_MISC_dr_mode 0x3e80 /* width RMuint32 */
+#define audio_MISC_dr_length 0x3e81 /* width RMuint32 */
+#define audio_MISC_dr_address 0x3e82 /* width RMuint32 */
+#define audio_MISC_dw_mode 0x3e84 /* width RMuint32 */
+#define audio_MISC_dw_length 0x3e85 /* width RMuint32 */
+#define audio_MISC_dw_address 0x3e86 /* width RMuint32 */
+#define audio_MISC_reset0 0x3e88 /* width RMuint32 */
+#define audio_MISC_reset1 0x3e89 /* width RMuint32 */
+#define audio_MISC_interrupt 0x3e8A /* width RMuint32 */
+#define audio_MISC_timer_div 0x3e8B /* width RMuint32 */
+#define audio_MISC_timer_count 0x3e8C /* width RMuint32 */
+#define audio_MISC_UNRESET_MASK 0xc300 /* width RMuint32 */
+#define audio_MISC_RESET_MASK 0xc3c3 /* width RMuint32 */
+#define audio_SP_init 0x1ffe /* width RMuint32 */
+/* AudioEngine registers done */
+
+/* AudioDecoder registers */
+/* AudioDecoder registers done */
+
+/* AudioCapture registers */
+/* AudioCapture registers done */
+
+/* CRCDecoder registers */
+/* CRCDecoder registers done */
+
+/* XCRCDecoder registers */
+/* XCRCDecoder registers done */
+
+/* StreamCapture registers */
+/* StreamCapture registers done */
+
+/* RawDataTransfer registers */
+/* RawDataTransfer registers done */
+
+/* I2C registers */
+#define I2C_MASTER_CONFIG 0x80 /* width RMuint32 */
+#define I2C_MASTER_CLK_DIV 0x84 /* width RMuint32 */
+#define I2C_MASTER_DEV_ADDR 0x88 /* width RMuint32 */
+#define I2C_MASTER_ADDR 0x8c /* width RMuint32 */
+#define I2C_MASTER_DATA_OUT 0x90 /* width RMuint32 */
+#define I2C_MASTER_DATA_IN 0x94 /* width RMuint32 */
+#define I2C_MASTER_STATUS 0x98 /* width RMuint32 */
+#define I2C_MASTER_STARTXFER 0x9c /* width RMuint32 */
+#define I2C_MASTER_BYTE_CNT 0xa0 /* width RMuint32 */
+#define I2C_MASTER_INTEN 0xa4 /* width RMuint32 */
+#define I2C_MASTER_INT 0xa8 /* width RMuint32 */
+#define I2C_SLAVE_ADDR_REG 0xC0 /* width RMuint32 */
+#define I2C_SLAVE_DATAOUT 0xC4 /* width RMuint32 */
+#define I2C_SLAVE_DATAIN 0xC8 /* width RMuint32 */
+#define I2C_SLAVE_STATUS 0xCC /* width RMuint32 */
+#define I2C_SLAVE_INTEN 0xD0 /* width RMuint32 */
+#define I2C_SLAVE_INT 0xD4 /* width RMuint32 */
+#define I2C_SLAVE_BUS_HOLD 0xD8 /* width RMuint32 */
+/* I2C registers done */
+
+/* GFXEngine registers */
+#define VO_graph_acc_reset_bit 0x0a /* width RMuint32 */
+#define VO_graph_acc_reset_mask 0x00300000 /* width RMuint32 */
+#define VO_graph_acc_reset_run 0x00000000 /* width RMuint32 */
+#define VO_graph_acc_reset_path 0x00100000 /* width RMuint32 */
+#define VO_graph_acc_reset_time 0x00200000 /* width RMuint32 */
+#define VO_graph_acc_reset_conf 0x00300000 /* width RMuint32 */
+#define VO_graph_acc_X_format 0x0a00 /* width RMuint32 */
+#define VO_graph_acc_X_alpha 0x0a04 /* width RMuint32 */
+#define VO_graph_acc_X_keycolor 0x0a08 /* width RMuint32 */
+#define VO_graph_acc_Y_format 0x0a0c /* width RMuint32 */
+#define VO_graph_acc_Y_keycolor 0x0a10 /* width RMuint32 */
+#define VO_graph_acc_control 0x0a14 /* width RMuint32 */
+#define VO_graph_acc_font 0x0a18 /* width RMuint32 */
+#define VO_graph_acc_lut0 0xd000 /* width RMuint32 */
+#define VO_graph_acc_FILL 0 /* width RMuint32 */
+#define VO_graph_acc_BLEND 1 /* width RMuint32 */
+#define VO_graph_acc_MOVE 2 /* width RMuint32 */
+#define VO_graph_acc_REPLACE 3 /* width RMuint32 */
+#define VO_graph_acc_RASTER 4 /* width RMuint32 */
+#define VO_graph_acc_mode_control 0x0a80 /* width RMuint32 */
+#define VO_graph_acc_DRAM_read_address 0x0a84 /* width RMuint32 */
+#define VO_graph_acc_DRAM_write_address 0x0a88 /* width RMuint32 */
+#define VO_graph_acc_X_bounding_box 0x0a8c /* width RMuint32 */
+#define VO_graph_acc_Y_bounding_box 0x0a90 /* width RMuint32 */
+#define VO_graph_acc_scaling_and_contours 0x0a94 /* width RMuint32 */
+#define VO_graph_acc_matrix_coeffs_scale 0x0a98 /* width RMuint32 */
+#define VO_graph_acc_matrix_coeffs_cross_scale 0x0a9c /* width RMuint32 */
+#define VO_graph_acc_matrix_coeffs_offset 0x0aa0 /* width RMuint32 */
+#define VO_graph_acc_grd_color0 0x0a40 /* width RMuint32 */
+#define VO_graph_acc_grd_color1 0x0a44 /* width RMuint32 */
+#define VO_graph_acc_grd_scale_factor 0x0a48 /* width RMuint32 */
+#define VO_graph_acc_grd_vt_scale_init 0x0a4c /* width RMuint32 */
+#define VO_graph_acc_grd_init_square_dist 0x0a50 /* width RMuint32 */
+#define VO_graph_acc_grd_ext_radius 0x0a54 /* width RMuint32 */
+#define VO_graph_acc_grd_int_radius 0x0a58 /* width RMuint32 */
+#define VO_graph_acc_grd_center 0x0a5c /* width RMuint32 */
+#define VO_graph_acc_grd_control 0x0a60 /* width RMuint32 */
+/* GFXEngine registers done */
+
+/* MM registers */
+/* MM registers done */
+
+/* SpuDecoder registers */
+/* SpuDecoder registers done */
+
+/* ClosedCaptionDecoder registers */
+/* ClosedCaptionDecoder registers done */
+
+/* RTC registers */
+/* RTC registers done */
+
+/* Cipher registers */
+/* Cipher registers done */
+
+/* STC registers */
+/* STC registers done */
+
+/* PLL registers */
+/* PLL registers done */
+
+/* DemuxTask registers */
+/* DemuxTask registers done */
+
+/* DemuxOutput registers */
+/* DemuxOutput registers done */
+
+/* CCFifo registers */
+/* CCFifo registers done */
+
+/* Sha1Sum registers */
+/* Sha1Sum registers done */
+
+/* XTask registers */
+/* XTask registers done */
+
+#endif /* __EMHWLIB_REGISTERS_TANGO2_H__ */
+
+/* End of generated file ../emhwlib_hal/include/tango2/emhwlib_registers_tango2.h */
diff -Naur linux.org/drivers/net/gnet/tango2/emhwlib_resources_tango2.h linux.patched/drivers/net/gnet/tango2/emhwlib_resources_tango2.h
--- linux.org/drivers/net/gnet/tango2/emhwlib_resources_tango2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.patched/drivers/net/gnet/tango2/emhwlib_resources_tango2.h	2005-07-29 10:11:27.501051748 +0200
@@ -0,0 +1,34 @@
+/*****************************************
+ Copyright © 2001-2003  
+ Sigma Designs, Inc. All Rights Reserved
+ Proprietary and Confidential
+ *****************************************/
+/**
+  @file   emhwlib_resources_tangolight.h
+  @brief  
+
+  long description
+
+  @author Emmanuel Michon
+  @date   2004-01-28y
+*/
+
+#ifndef __EMHWLIB_RESOURCES_TANGOLIGHT_H__
+#define __EMHWLIB_RESOURCES_TANGOLIGHT_H__
+
+#define VSYNC_PARAM_MUTEX   ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex2))
+#define PCI_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex3))
+#define GFX_MUTEX           ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex4))
+#define HOST_MBUS_MUTEX     ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex5))
+#define SOFT_IRQ_MUTEX_TASK ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex6))
+#define SOFT_IRQ_MUTEX_IRQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex7))
+#define SOFT_IRQ_MUTEX_FIQ  ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex8))
+#define RTC_IRQ_MUTEX       ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex9))
+#define XRPC_MUTEX          ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex10))
+#define XTASK_MUTEX         ((struct gbus_mutex *)(REG_BASE_host_interface  + host_mutex11))
+
+#define AUDIO_0_IRQ_MUTEX   ((struct gbus_mutex *)(DMEM_BASE_audio_engine_0 + 4 * audio_mutex0))
+#define VIDEO_0_FIFO_MUTEX  ((struct gbus_mutex *)(DMEM_BASE_mpeg_engine_0  + 4 * mpeg_mutex0))
+#define DEMUX_IRQ_MUTEX     ((struct gbus_mutex *)(DMEM_BASE_demux_engine   + 4 * demux_mutex0))
+
+#endif // __EMHWLIB_RESOURCES_TANGOLIGHT_H__
diff -Naur linux.org/README.1015.gnet.patch linux.patched/README.1015.gnet.patch
--- linux.org/README.1015.gnet.patch
+++ linux.patched/README.1015.gnet.patch
@@ -0,0 +1,19 @@
+Feature:
+-------
+GNET patch
+
+Prerequisite patch numbers:
+--------------------------
+*** TBD
+
+Primary author:
+--------------
+*** TBD
+
+Related to which chip version?
+-----------------------------
+*** TBD
+
+(linux patches) which CONFIG_... are provided:
+---------------------------------------------
+*** TBD
